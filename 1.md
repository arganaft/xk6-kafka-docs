Для подключения Redis к вашему Spring Boot приложению с учетом уже готового `application.yml`, вам осталось выполнить несколько шагов: добавить зависимости и настроить бины для работы с данными.

Поскольку у вас указан **Redis Cluster** и используется **Lettuce** с пулом соединений (`pool`), важно не забыть специфическую зависимость для пула.

---

### 1. Добавьте зависимости

В файл `pom.xml` (для Maven) добавьте стартер для Redis и библиотеку `commons-pool2` (она обязательна, если вы используете `lettuce.pool` в настройках).

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>

    <dependency>
        <groupId>org.apache.commons.pool2</groupId>
        <artifactId>commons-pool2</artifactId>
    </dependency>
</dependencies>

```

---

### 2. Создайте конфигурационный класс

Spring Boot автоматически подхватит настройки из `application.yml`, но для удобной работы лучше явно настроить `RedisTemplate`. По умолчанию он использует Java-сериализацию (данные в Redis будут выглядеть как «кракозябры»). Лучше использовать JSON или строки.

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        
        // Ключи всегда строки
        template.setKeySerializer(new StringRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        
        // Значения сериализуем в JSON для читаемости в Redis CLI
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        
        return template;
    }
}

```

---

### 3. Пример использования в сервисе

Теперь вы можете внедрить `RedisTemplate` в любой ваш сервис и использовать его:

```java
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import java.util.concurrent.TimeUnit;

@Service
public class SearchCacheService {

    private final RedisTemplate<String, Object> redisTemplate;

    public SearchCacheService(RedisTemplate<String, Object> redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    public void saveToCache(String key, Object value) {
        // Сохраняем данные на 10 минут
        redisTemplate.opsForValue().set(key, value, 10, TimeUnit.MINUTES);
    }

    public Object getFromCache(String key) {
        return redisTemplate.opsForValue().get(key);
    }
}

```

---

### На что обратить внимание:

* **Cluster Mode**: Spring Boot поймет, что это кластер, благодаря структуре `spring.data.redis.cluster.nodes`.
* **Redirects**: У вас указано `max-redirects: 5`. Это стандартно для кластера, чтобы клиент мог найти нужный слот, если он переехал на другой узел.
* **Timeout**: Вы используете переменную `${REDIS_CONNECTION_TIMEOUT:15000}`. Убедитесь, что она передается в окружении (например, в Docker/K8s), иначе применится дефолт 15 секунд.

**Хотите, я помогу составить DTO и пример того, как кэшировать результаты поиска из БД (PostgreSQL), которая у вас также настроена?**
