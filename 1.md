<think>**Analyzing the Error**

The user is encountering a `GoError: unsupported database: invalid driver parameter type` during the `setup()` phase. The error points to line 42 (approximately) in the script. The user provided a snippet of line 42 from their perspective, but the error message `at setup (file:///scripts/test.js:42:22(14))` strongly suggests the issue originates from the `sql.open()` call or the query execution itself, specifically related to how the driver or connection string is being handled.

**Deconstructing the Error Message**

*   `GoError: unsupported database: invalid driver parameter type`: This is a specific error from the Go runtime, likely propagated through `xk6-sql`. It usually means the first argument to `sql.open()` is not a string or the driver name is unrecognized, OR the connection string (second argument) is malformed or of the wrong type.
*   `at setup`: Confirms the error is in the setup function.
*   Line 42: In the previous "RAM-based" example I provided, line 42 was inside the `while` loop, specifically the `sql.query` call or the error handling block. However, the error "unsupported database" typically happens at `sql.open`. Let's look at the `sql.open` line in my previous code: `const db = sql.open('postgres', connectionString);`.

**Hypothesis Generation**

1.  **Driver Name:** The first argument `'postgres'` is standard for `xk6-sql`. Unless the extension wasn't built with the postgres driver (which is the default usually), this should be fine.
2.  **Connection String Type:** The connection string is constructed using template literals. It *should* be a string.
3.  **The Actual Culprit (Most Likely):** The error `invalid driver parameter type` often occurs in `xk6-sql` if the *driver name* isn't passed correctly or if the underlying Go SQL driver doesn't support the connection string format provided, but the specific phrasing "invalid driver parameter type" makes me suspect the `sql.open` call signature.
    *   Wait, looking at `xk6-sql` documentation/examples... `sql.open(driverName, dataSourceName)`. Both must be strings.
    *   Let's look at the error again: `unsupported database`. This might mean the *driver* "postgres" isn't registered.
    *   **Crucial check:** Does the user's K6 image actually have `xk6-sql` with Postgres support? The error "unsupported database" is the standard `database/sql` error when a driver is not imported.
    *   **Alternative:** The connection string format. The user provided a JDBC URL. I converted it to `postgres://`. However, some older Postgres drivers or specific setups might prefer key-value pairs (DSN) like `user=postgres password=...`. But `postgres://` (URI) is generally supported by `lib/pq` and `pgx`.

**Re-evaluating the Line Number**

The user says line 42 contains `console.error`. If the error is `unsupported database`, it almost certainly happened *before* the query loop, at `sql.open`. If the user's file has extra headers or empty lines, line 42 might be `const db = sql.open(...)`.

**Wait, let's look at the error "invalid driver parameter type" specifically.**

If I search for this error in the context of Go `database/sql` or `xk6-sql`:
It's not a standard Go `database/sql` error. Standard is `sql: unknown driver "..."`.
"invalid driver parameter type" sounds like an issue in the binding between JS (k6) and Go.

*Self-Correction:* If the user is using a *very* recent or specific version of `xk6-sql`, maybe the API changed? No, it's stable.
Let's look at the connection string construction again.
`const connectionString = ...`
If any of the environment variables (`__ENV.DB_USER`) are `undefined`, the string becomes `postgres://undefined:undefined...`. This is a valid string, just invalid credentials. It wouldn't cause "invalid driver parameter type".

**Let's look at the JDBC URL provided:**
`jdbc:postgresql://tvled-kssh00010.esrt.sber.ru:12541,tvled-kssh00012.esrt.sber.ru:12543/mr...`
I converted this to a single host.

**The "Unsupported Database" Error**

This is the key. In Go's `sql.Open("driver", "dsn")`, if "driver" isn't registered, it panics or errors.
BUT, the error message `GoError: unsupported database: invalid driver parameter type` looks like it might be coming from the *k6 script runtime* trying to interpret the arguments passed to `sql.open`.

**Wait, I might have missed a detail in `xk6-sql`.**
Is it possible the user is running a standard K6 image *without* the extension?
If they run standard K6, `import sql from 'k6/x/sql';` would fail with "module not found" or similar *before* execution, unless they are using a build that *has* the module but maybe not the driver? No, `xk6-sql` bundles drivers.

**Let's look at the specific error text again.**
`GoError: unsupported database: invalid driver parameter type`

Actually, there is a known issue/confusion often with `xk6-sql`.
The driver name for PostgreSQL in `xk6-sql` (which uses `lib/pq` usually) is `postgres`.
However, if the connection string is passed as an object instead of a string? No, I passed a string.

**Let's try a different angle.**
Maybe the `sql` object isn't imported correctly?
`import sql from 'k6/x/sql';` -> This is correct for the extension.

**What if the error is actually in `sql.query`?**
The user says the error happens at line 42.
In my previous code:
Line 38: `const db = sql.open(...)`
Line 42 (approx): `const results = sql.query(db, query);`

If `sql.open` failed but didn't throw (it returns a db object usually, errors happen on ping or query), then `db` might be in a bad state.
However, `sql.open` in Go doesn't connect. It just validates arguments.
If `sql.query` is called, and `db` is somehow invalid or the driver type inside `db` is wrong...

**Wait, I found a similar issue online.**
The error `unsupported database: invalid driver parameter type` suggests that the first argument to `sql.open` might not be a string in the way K6 expects it, or the internal mapping is failing.

**BUT, there is a distinct possibility:**
The user might be using a K6 binary that has `k6/x/sql` but the driver string `'postgres'` is not matching what's compiled in.
Usually, `xk6-sql` supports: `postgres`, `mysql`, `sqlite3`, `sqlserver`.

**Let's look at the Connection String again.**
`postgres://user:pass@host:port/dbname...`
If the password contains special characters (like `@`, `:`, `/`), the URL parsing in the driver will fail unless they are URL-encoded.
`postgres123` is safe.
The host `tvled-kssh00010.esrt.sber.ru` is safe.

**Let's look at the error location again.**
`at setup (file:///scripts/test.js:42:22(14))`
If line 42 is indeed inside the loop where `sql.query` is called.
`sql.query(db, query)`
Argument 1: `db` object returned from `open`.
Argument 2: `query` string.

If `db` is not a valid database object, `xk6-sql` might throw this.
Why would `db` be invalid?
Maybe `sql.open` failed silently or returned something unexpected?
Actually, `sql.open` in `xk6-sql` throws an error if it fails.

**Let's reconsider the "unsupported database" part.**
This often implies the *connection string scheme* doesn't match the driver, or the driver itself isn't found.
But the error says "invalid driver parameter type".

**Hypothesis: The Connection String format.**
The user provided a JDBC URL with failover (comma-separated hosts): `jdbc:postgresql://host1:port1,host2:port2/db`.
I simplified it to one host.
However, if the user copied the code exactly, it should work.

**What if the user's K6 version is old or the extension is old?**
There was a breaking change in `xk6-sql` a while back regarding how `query` works. It used to be `sql.query(db, query, ...params)`.

**Let's look at the error again: `GoError: unsupported database: invalid driver parameter type`**
This error comes from `k6/x/sql` when the `db` object passed to `query` is not what it expects.
Wait! In older versions or specific forks, `sql.open` might return a struct that isn't directly compatible if not handled right? Unlikely.

**Let's look at the `sql.open` line.**
`const db = sql.open('postgres', connectionString);`
Is it possible `connectionString` is not a string?
`const connectionString = ...` (template literal) -> It is a string.

**Is it possible `sql` is not the module?**
`import sql from 'k6/x/sql';`

**Let's try a different approach.**
The error `unsupported database` usually comes from the Go SQL driver registry.
If I look at the source code for `xk6-sql`:
It calls `sql.Open(driver, dsn)`.
If that returns an error, it throws.

**Wait, look at the error trace again.**
`at reflect.methodValueCall (native)`
`at setup ...`

**Is it possible the user is running this on Windows/locally and the file path is weird?** No, it's Kubernetes (`/scripts/test.js`).

**Let's focus on the "invalid driver parameter type".**
This specific string "invalid driver parameter type" is NOT a standard Go error.
It looks like it might be a *JavaScript* to *Go* conversion error in the K6 bridge (k6/js/modules).
It implies that one of the arguments passed to the Go function is of the wrong type.

Function: `sql.query(db, query)`
Arg 1: `db`. This should be the object returned by `sql.open`.
Arg 2: `query`. String.

If `sql.open` failed to return a proper `db` object (e.g. returned `undefined` or `null` because of an error caught/suppressed, or just failed), then passing `undefined` to `sql.query` as the first argument would cause "invalid driver parameter type" because it expects a `*sql.DB` struct.

**BUT**, `sql.open` usually throws.

**Let's look at the user's snippet.**
The user says line 42 contains `console.error`.
In my RAM-based code:
Line 38: `const db = sql.open(...)`
Line 42: `const results = sql.query(db, query);` (In the loop).

If the user says line 42 is `console.error`, they might be using the *File-based* variant or a modified version.
In the File-based variant:
Line 38: `const db = sql.open(...)`
Line 42: `try { file.delete(FILE_PATH); }` -> No.
Line 45: `while...`
Line 47: `const query = ...`
Line 48: `const results = sql.query(db, query);`

If the user's line 42 is `console.error`, they might have added logging.

**Let's assume the error is in `sql.open` or `sql.query`.**

**Most likely cause:**
The connection string format `postgres://` is strictly for `lib/pq` (which `xk6-sql` uses).
However, if the password contains special chars, it breaks.
The user provided `${DB_PASSWORD:postgres123}`.
If the actual password has a symbol like `#` or `?`, the URI parser breaks.

**Proposed Solution Strategy:**
1.  **Switch to Key-Value Connection String (DSN):** Instead of `postgres://user:pass@host...`, use `host=... port=... user=... password=... dbname=... sslmode=...`. This is much safer and avoids URL encoding issues.
2.  **Verify `sql.open`:** Ensure `db` is checked before use (though it's hard to check strictly in JS k6 without try/catch).
3.  **Debug Logging:** Add `console.log` to print the connection string (masking password) to ensure variables are loaded.

**Another possibility:**
The user is using a K6 image where `xk6-sql` was built with a different driver name or version.
But the "invalid driver parameter type" strongly suggests the `db` object passed to `query` is invalid.
Why would `db` be invalid?
Maybe `sql.open` didn't actually return the DB object correctly due to the connection string format.

Let's rewrite the connection string to the DSN format (Key-Value). It's more robust.
`host=tvled-kssh00010.esrt.sber.ru port=12541 user=postgres password=postgres123 dbname=mr sslmode=disable`

**Also, check the `sql.query` syntax.**
`sql.query(db, query)` is correct.

**One more thing:**
The error `unsupported database` might actually be the *Go* error `sql: unknown driver "postgres"`.
This happens if the `xk6-sql` binary was built *without* the postgres tag?
No, `xk6-sql` includes postgres by default.
BUT, if the user is using a generic "k6 with extensions" image found online, it might not have it.
However, I must assume they have the tool.

**Focusing on the "invalid driver parameter type" again.**
If `sql.open` returns `undefined`, passing it to `sql.query` causes a type mismatch in the Go bridge.
Why would `sql.open` return undefined?
If the driver name "postgres" is wrong?
Or if the connection string is empty?

**Let's provide a fix that:**
1.  Uses the Key-Value (DSN) format for the connection string to avoid URI parsing errors.
2.  Adds debug logs to verify `db` object creation.
3.  Wraps `sql.open` in a try-catch to see if it explodes there.

**Wait, looking at the user's error log again:**
`at setup (file:///scripts/test.js:42:22(14))`
Line 42, column 22.
If the line is `const results = sql.query(db, query);`
Column 22 is right around `db`.
This confirms `db` is likely the issue. It's probably `null` or `undefined` or not the expected Go struct.

**Why did `sql.open` fail?**
If `sql.open` failed, it usually throws an exception in JS.
Unless... `xk6-sql` behavior changed.
But wait, `sql.open` in Go *never* connects. It just validates arguments.
If arguments are valid strings, it returns a DB object.
So `db` should be an object.

**Is it possible `sql` variable is shadowing something?**
No.

**Let's look at the error `unsupported database` again.**
This is the error message string.
If I search `xk6-sql "unsupported database"`.
I see issues related to `unknown driver`.
If the driver name is wrong.
Is it `postgresql` instead of `postgres`?
`lib/pq` registers as `postgres`. `pgx` registers as `pgx`.
Standard `xk6-sql` uses `postgres`.

**Maybe the connection string is the issue.**
If the connection string is invalid, `sql.Open` might still succeed in Go, but `sql.Query` (which triggers the connection) will fail.
If `sql.Query` fails, it returns a Go error.
Does that Go error translate to `GoError: unsupported database...`?
"Unsupported database" is not a standard Postgres connection error (usually "connection refused", "password auth failed").

**Wait!**
Is it possible the user is using `k6` **without** `xk6-sql` properly installed/referenced, or using a version where `sql` is not what we think it is?
If `import sql from 'k6/x/sql'` works, the module is there.

**Let's try the DSN format.**
It is much less prone to "parameter type" interpretation errors than the URI format in some Go libraries if the URI is malformed.

**Also, the JDBC URL has multiple hosts.**
`jdbc:postgresql://host1:port1,host2:port2/db`
I used only `host1`.
If the user's environment requires the specific failover syntax, standard `lib/pq` might not support it (it only supports single host usually, though recent versions might). But `pgx` does. `xk6-sql` usually uses `lib/pq`.
So sticking to one host is safer.

**Let's refine the script.**
I will rewrite the connection string construction to use `host=... port=...` syntax.
I will also add a check to see if `db` is created.

**One specific edge case:**
If `DB_PASSWORD` is not set in the environment, `__ENV.DB_PASSWORD` is undefined.
`const dbPass = __ENV.DB_PASSWORD || 'postgres123';` handles this.
But if `__ENV` is somehow not working (e.g. context issues), it defaults.

**Let's look at the error `invalid driver parameter type` one last time.**
This sounds like the K6 runtime complaining about the arguments passed to `sql.open` or `sql.query`.
If `sql.open` was `sql.open(123, 456)`, it would say invalid parameter type.
Here we pass strings.

**Wait.**
Maybe the user's K6 version requires `sql.open` to take a *third* argument? No.
Maybe the user's `xk6-sql` is very old?

**Let's assume the Connection String URI parsing is the culprit.**
If the password has a special char, `postgres://user:p@ss@host...` -> The parser sees `@ss` as the host start.
This creates a mess.
The DSN format `password='p@ss'` handles this.

**Plan:**
1.  Explain that the error likely indicates an issue with the Connection String format or the `db` object initialization.
2.  Provide the **DSN (Key-Value)** format fix.
3.  Add explicit Try-Catch around `sql.open`.
4.  Verify the `sql.query` call.

**Revised Code Snippet for the User:**
I will provide the corrected `setup` function and the connection string definition using DSN format.

**Wait, the user said:**
`in yml /scripts/test.js file on the stand line 42 contains: {\n console.error(\"SQL Error:\", e);\n break;\n`
This looks like the `catch` block of the `while` loop in my previous RAM-based example.
If the error is happening *there*, it means the `try` block failed.
`try { const results = sql.query(db, query); ... } catch (e) ...`
But the error printed is `ERRO[0000] GoError: ...`.
If it was caught in `catch(e)`, it would print `SQL Error: GoError...`.
The output shows `ERRO[0000] GoError...` directly from K6 runner, which means it was **uncaught** or happened outside the try/catch?
Or maybe `console.error` prints `ERRO`? Yes, `console.error` in K6 prints `ERRO[...]`.
So the error IS being caught and printed by `console.error`.
The error message is `GoError: unsupported database: invalid driver parameter type`.

So, `sql.query(db, query)` is throwing this.
This means `db` is successfully created (is an object), but when `query` tries to use it, it fails.
"Unsupported database" inside `query`?
This implies the driver associated with `db` is not working or the connection string was parsed but the driver didn't know how to handle it *at query time*? No, `open` binds the driver.

**Actually, look at this:**
`sql.open` returns a `*sql.DB`.
If the driver name "postgres" was wrong, `open` would likely fail.
If `open` succeeded, `db` is valid struct.
If `query` fails with "unsupported database", it sounds like the *connection string* passed to `open` was valid as a string, but logically invalid for the driver, and the driver is complaining "I don't support this database/dsn format".

**BUT**, "invalid driver parameter type" is very specific.
It sounds like `xk6-sql` internal reflection issue.

**Let's try to simplify the connection string.**
Switching to DSN (`host=...`) is the standard fix for "weird URI parsing issues".

**Also, check the imports.**
`import sql from 'k6/x/sql';`
Make sure the user isn't using `k6/x/sql` in a way that conflicts with another module.

**Conclusion:**
The Connection String URI format is likely the problem (special chars in password or username, or just strict parsing in the Go driver).
I will suggest switching to `key=value` format.

**One more check:**
The user provided JDBC URL: `jdbc:postgresql://...`
I converted to `postgres://...`.
If the user used the code *exactly* as I gave, and it failed.
Maybe the port `12541` is unusual? No.
Maybe SSL? `sslmode=disable`.

**Let's provide the Key-Value string solution.**

```javascript
const connectionString = `host=${dbHost} port=${dbPort} user=${dbUser} password=${dbPass} dbname=${dbName} sslmode=disable`;
```
This is much safer.

Also, I will advise checking if the `xk6-sql` extension is actually present and supports postgres (which it should, but good to verify).

**Regarding the Line 42 mismatch:**
If the user says line 42 is the catch block, then `sql.query` is definitely throwing.
The error message `invalid driver parameter type` is the `e.message`.
This confirms `sql.query` is the thrower.
And since `db` comes from `open`, and `query` is a string...
The only "parameter" that could be invalid type is `db` (if it's not a DB object) or `query` (if not string).
Since `query` is constructed via template literal, it's a string.
So `db` is suspect.
But `sql.open` returns it.

**Is it possible `sql.open` failed silently?**
I'll add a check: `if (!db) throw new Error("DB open failed");`

**Final Plan:**
1.  Change connection string to Key-Value format.
2.  Add error handling around `sql.open`.
3.  Explain the likely cause (URI parsing).

**Wait, looking at the error `unsupported database: invalid driver parameter type` one last time.**
This error appears in some contexts where `sql.Open` is called with a driver name that expects a specific type of DSN object, but here we pass string.
Actually, I suspect the `postgres://` scheme might be triggering a driver that expects something else in this specific build of K6, OR the parsing of the URI failed so badly it passed a nil or weird struct to the internal driver.
Switching to DSN `key=value` is the most robust fix.

**Also, the user's JDBC URL has `currentSchema=murex`.**
In Postgres URI: `search_path=murex`.
In DSN: `search_path=murex`.
I will include that.

**Let's write the response.**
The error `GoError: unsupported database: invalid driver parameter type` usually возникает, когда драйвер базы данных (в данном случае `postgres` внутри Go) не может корректно разобрать строку подключения (Connection String) или когда переданный объект `db` поврежден.

Чаще всего проблема кроется в формате строки подключения `postgres://...`, особенно если в пароле есть спецсимволы, или если версия драйвера в `xk6-sql` строга к формату.

**Решение:** Переделать строку подключения в формат `key=value` (DSN), который гораздо надежнее.

I will provide the corrected ConfigMap (Variant 2, as it's the one they seem to be running based on the loop logic). I'll also update Variant 1 just in case.

**Wait, user asked for "2 variants" again?**
No, they just showed the error and asked for help.
I should provide the fix for the code they are running.
They quoted the error and the file content.
I will provide the corrected `setup` function and the connection string logic.

**Double check the port.**
User: `tvled-kssh00010.esrt.sber.ru:12541`
My code: `const dbPort = '12541';`
Correct.

**Double check the schema.**
User: `currentSchema=murex`
My code: `search_path=murex`
Correct.

**Double check the DB name.**
User: `/mr`
My code: `dbname = 'mr'`
Correct.

**Let's construct the fix.**Ошибка `GoError: unsupported database: invalid driver parameter type` чаще всего возникает в `xk6-sql` по двум причинам:
1.  **Формат строки подключения:** Использование формата URI (`postgres://...`) может вызывать ошибки парсинга в</think> Go-драйвере, особенно если в пароле есть спецсимволы или если драйвер ожидает параметры в другом виде.
2.  **Проблема с объектом `db`:** Если `sql.open` не смог инициализировать структуру, но не упал сразу, то `sql.query` выдаст эту ошибку, так как получит некорректный объект.

**Решение:** Самый надежный способ исправить это — переписать строку подключения (`connectionString`) из формата URL в формат **Key-Value (DSN)**. Это исключает ошибки парсинга спецсимволов.

Вот исправленный вариант (на примере Варианта 2, который вы запускали), где изменена логика формирования строки подключения:

### Исправленный ConfigMap (Вариант 2 - RAM)

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: k6-test-scripts-ram-based
  labels:
    app: syngtp-k6-load-test-rest-db-reader
data:
  test.js: |
      import http from 'k6/http';
      import { check } from 'k6';
      import { Rate, Trend } from 'k6/metrics';
      import sql from 'k6/x/sql';

      const successRate = new Rate('successful_requests');
      const requestDuration = new Trend('request_duration');

      // Конфигурация
      const DB_LIMIT = __ENV.DB_LIMIT || 10000;
      const CHUNK_SIZE = 2000;

      // --- ИСПРАВЛЕНИЕ ЗДЕСЬ ---
      // Используем Key-Value формат вместо postgres://
      const dbUser = __ENV.DB_USER || 'postgres';
      const dbPass = __ENV.DB_PASSWORD || 'postgres123';
      const dbHost = 'tvled-kssh00010.esrt.sber.ru';
      const dbPort = '12541';
      const dbName = 'mr';
      
      // Формируем строку DSN (Data Source Name)
      // Это предотвращает ошибки парсинга спецсимволов в пароле и URL
      const connectionString = `host=${dbHost} port=${dbPort} user=${dbUser} password=${dbPass} dbname=${dbName} sslmode=disable search_path=murex`;

      export const options = {
        executor: 'constant-arrival-rate',
        rate: 20,
        timeUnit: '1s',
        preAllocatedVUs: 2,
        maxVUs: 5,
        stages: [
              { duration: '3s', target: 2 },
              { duration: '10s', target: 5 },
              { duration: '5s', target: 5 },
        ],
        thresholds: {
          http_req_failed: ['rate<0.01'],
          http_req_duration: ['p(95)<20000'],
          'successful_requests': ['rate>0.99'],
        },
      };

      export function setup() {
        console.log(`Connecting to DB host: ${dbHost} port: ${dbPort}...`);
        
        // Добавляем try-catch вокруг открытия, чтобы поймать ошибку инициализации
        let db;
        try {
            db = sql.open('postgres', connectionString);
        } catch (e) {
            console.error("FATAL: Could not open DB connection:", e);
            throw e;
        }

        let allIds = [];
        let offset = 0;

        console.log(`Starting fetch of ${DB_LIMIT} IDs...`);

        while (allIds.length < DB_LIMIT) {
            // Исправленный запрос
            const query = `SELECT id FROM murex.trades ORDER BY created_at DESC LIMIT ${CHUNK_SIZE} OFFSET ${offset};`;
            
            try {
                const results = sql.query(db, query);
                
                if (!results || results.length === 0) {
                    console.log("No more rows returned from DB.");
                    break;
                }
                
                results.forEach(r => allIds.push(r.id));
                offset += results.length;
                console.log(`Loaded ${allIds.length} IDs so far...`);
                
            } catch (e) {
                // Вот здесь у вас падало. Теперь мы увидим более точную ошибку, если она останется.
                console.error(`SQL Query Error at offset ${offset}:`, e);
                // Если ошибка критическая, лучше прервать setup, иначе тест пойдет без данных
                sql.close(db);
                throw new Error("Failed to execute SQL query: " + e);
            }
        }

        sql.close(db);
        console.log(`Setup complete. Total IDs in RAM: ${allIds.length}`);
        
        if (allIds.length === 0) {
            throw new Error("No IDs were loaded from Database! Cannot start test.");
        }

        return { ids: allIds };
      }

      export default function (data) {
        if (!data || !data.ids || data.ids.length === 0) {
           console.error("No IDs available in default function");
           return;
        }

        const ids = data.ids;
        const randomId = ids[Math.floor(Math.random() * ids.length)];
        const url = `http://trade-consumer-db-reader:8080/api/trades/${randomId}`;
        
        const params = {
          headers: {
            'User-Agent': 'k6-load-test',
            'Content-Type': 'application/json',
          },
          timeout: '30s',
          tags: { endpoint: 'get_trade' },
        };
        
        try {
          const response = http.get(url, params);
          
          requestDuration.add(response.timings.duration);
          successRate.add(response.status === 200);
          
          check(response, {
            'status is 200': (r) => r.status === 200,
            'response time < 20s': (r) => r.timings.duration < 20000,
          });
          
        } catch (error) {
          successRate.add(false);
          console.error(`Request error: ${error.message}`);
        }
      }

      export function teardown(data) {
        data = null; 
      }
```

### Что изменилось:
1.  **Connection String:** Заменена с `postgres://user:pass@host...` на `host=... port=... user=...`. Это "родной" формат для библиотеки `lib/pq` (которую использует Go под капотом), он гораздо стабильнее.
2.  **Обработка ошибок:** Добавлен `try/catch` вокруг `sql.open`, чтобы убедиться, что объект базы создается.
3.  **Критический выход:** Если `sql.query` падает, скрипт теперь выбрасывает `throw new Error`, чтобы остановить тест сразу, а не пытаться работать с пустыми данными.
