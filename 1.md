Вот конфигурационный файл для K6, который будет генерировать данные и напрямую записывать их в PostgreSQL:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: k6-test-scripts
  labels:
    app: syngtp-k6-load-test-postgres-writer
data:
  test.js: |
    import { check, sleep } from 'k6';
    import { Rate, Trend, Counter } from 'k6/metrics';
    import sql from 'k6/x/sql';
    import postgresDriver from 'k6/x/sql/driver/postgres';
    
    // Custom metrics
    const insertSuccessRate = new Rate('db_insert_success');
    const insertDuration = new Trend('db_insert_duration');
    const insertsCount = new Counter('db_inserts_total');
    const errorsCount = new Counter('db_errors_total');
    
    // Test configuration
    export const options = {
      scenarios: {
        postgres_load: {
          executor: 'ramping-arrival-rate',
          startRate: 100,
          timeUnit: '1s',
          preAllocatedVUs: 50,
          maxVUs: 200,
          stages: [
            { duration: '10s', target: 1000 },
            { duration: '30s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '10s', target: 0 },
          ],
        },
      },
      thresholds: {
        'db_insert_success': ['rate>0.95'],
        'db_insert_duration': ['p(95)<1000', 'p(99)<2000'],
        'db_errors_total': ['count<1000'],
        'iteration_duration': ['p(95)<2000'],
      },
    };
    
    // Database configuration
    const dbUser = '__DB_USERNAME__';
    const dbPass = '__DB_PASSWORD__';
    const dbHost = 'tvled-kssh00010.esrt.sber.ru';
    const dbPort = '12541';
    const dbName = 'mr';
    
    const connectionString = `host='${dbHost}' port='${dbPort}' user='${dbUser}' password='${dbPass}' dbname='${dbName}' sslmode='disable' search_path='murex'`;
    
    // Sample instruments for variety
    const instruments = [
      'USD/RUB', 'EUR/USD', 'GBP/USD', 'USD/JPY',
      'BTC/USD', 'ETH/USD', 'SBER', 'GAZP'
    ];
    
    const sides = ['BUY', 'SELL'];
    
    function generateTrade() {
      const now = new Date();
      const isoTimestamp = now.toISOString();
      const instrument = instruments[Math.floor(Math.random() * instruments.length)];
      const side = sides[Math.floor(Math.random() * sides.length)];
      const timestamp = Date.now();
      
      const tradeId = `TRD-K6-${timestamp}-${Math.random().toString(36).substr(2, 9)}`;
      
      return {
        id: tradeId,
        trade_data: {
          tradeId: tradeId,
          exchangeTradeId: `EX-${timestamp}`,
          timestamp: isoTimestamp,
          executionTime: isoTimestamp,
          instrument: {
            symbol: instrument,
            type: instrument.includes('/') ? 'FX_SPOT' : 'EQUITY',
            exchange: 'TEST',
            currency: 'USD'
          },
          side: side,
          orderType: 'LIMIT',
          quantity: Math.floor(Math.random() * 10000) + 1000,
          price: Math.random() * 100 + 50,
          amount: Math.random() * 1000000,
          client: {
            id: `CLI-${Math.floor(Math.random() * 100)}`,
            account: `ACC-${Math.floor(Math.random() * 10)}`,
            type: 'INSTITUTIONAL'
          },
          metadata: {
            source: 'K6_TEST',
            version: '1.0',
            sequenceNumber: timestamp,
            latencyMs: Math.random() * 10
          }
        }
      };
    }
    
    export default function () {
      const db = sql.open(postgresDriver, connectionString);
      
      try {
        const trade = generateTrade();
        const tradeDataJson = JSON.stringify(trade.trade_data);
        
        const insertQuery = `
          INSERT INTO murex.trades (id, trade_data, created_at)
          VALUES ($1, $2::jsonb, NOW())
        `;
        
        const startTime = Date.now();
        
        try {
          db.exec(insertQuery, trade.id, tradeDataJson);
          
          const duration = Date.now() - startTime;
          insertDuration.add(duration);
          insertSuccessRate.add(true);
          insertsCount.add(1);
          
          check(null, {
            'trade inserted successfully': () => true,
          });
          
        } catch (execError) {
          const duration = Date.now() - startTime;
          insertDuration.add(duration);
          insertSuccessRate.add(false);
          errorsCount.add(1);
          
          console.error(`[VU ${__VU}] Insert failed: ${execError.message}`);
          
          check(null, {
            'trade inserted successfully': () => false,
          });
        }
        
      } catch (error) {
        errorsCount.add(1);
        insertSuccessRate.add(false);
        console.error(`[VU ${__VU}] Unexpected error: ${error.message}`);
      } finally {
        db.close();
      }
    }
    
    export function teardown() {
      console.log('Load test completed');
    }
```

## Ключевые особенности этого конфигурационного файла:

1. **Генерация данных**: Использует ту же логику генерации трейдов, что и в первом файле (Kafka producer)

2. **Прямая запись в PostgreSQL**: 
   - Открывает соединение с БД для каждой итерации
   - Выполняет INSERT напрямую в таблицу `murex.trades`
   - Использует параметризованный запрос для безопасности
   - Автоматически проставляет `created_at` через `NOW()`

3. **Метрики**:
   - `db_insert_success` - процент успешных вставок
   - `db_insert_duration` - время выполнения INSERT
   - `db_inserts_total` - общее количество вставок
   - `db_errors_total` - количество ошибок

4. **Профиль нагрузки**: Идентичен первому файлу (до 12000 операций/сек)

5. **Обработка ошибок**: 
   - Try-catch блоки для отлова ошибок БД
   - Логирование ошибок с номером VU
   - Закрытие соединений в finally блоке

6. **Пороговые значения (thresholds)**:
   - Успешность вставок > 95%
   - 95-й перцентиль длительности < 1 сек
   - 99-й перцентиль < 2 сек

**Примечание**: Замените `__DB_USERNAME__` и `__DB_PASSWORD__` на реальные учетные данные перед запуском теста.
