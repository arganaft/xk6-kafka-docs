Вот конфигурационный файл для K6, который будет генерировать данные и напрямую записывать их в PostgreSQL:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: k6-test-scripts
  labels:
    app: syngtp-k6-load-test-postgres-writer
data:
  test.js: |
    import { check, sleep } from 'k6';
    import { Rate, Trend, Counter } from 'k6/metrics';
    import sql from 'k6/x/sql';
    import postgresDriver from 'k6/x/sql/driver/postgres';
    
    // Custom metrics
    const insertSuccessRate = new Rate('db_insert_success');
    const insertDuration = new Trend('db_insert_duration');
    const insertsCount = new Counter('db_inserts_total');
    const errorsCount = new Counter('db_errors_total');
    
    // Test configuration
    export const options = {
      scenarios: {
        postgres_load: {
          executor: 'ramping-arrival-rate',
          startRate: 100,
          timeUnit: '1s',
          preAllocatedVUs: 50,
          maxVUs: 200,
          stages: [
            { duration: '10s', target: 1000 },
            { duration: '30s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '10s', target: 0 },
          ],
        },
      },
      thresholds: {
        'db_insert_success': ['rate>0.95'],
        'db_insert_duration': ['p(95)<1000', 'p(99)<2000'],
        'db_errors_total': ['count<1000'],
        'iteration_duration': ['p(95)<2000'],
      },
    };
    
    // Database configuration
    const dbUser = '__DB_USERNAME__';
    const dbPass = '__DB_PASSWORD__';
    const dbHost = 'tvled-kssh00010.esrt.sber.ru';
    const dbPort = '12541';
    const dbName = 'mr';
    
    const connectionString = `host='${dbHost}' port='${dbPort}' user='${dbUser}' password='${dbPass}' dbname='${dbName}' sslmode='disable' search_path='murex'`;
    
    // Sample instruments for variety
    const instruments = [
      'USD/RUB', 'EUR/USD', 'GBP/USD', 'USD/JPY',
      'BTC/USD', 'ETH/USD', 'SBER', 'GAZP'
    ];
    
    const sides = ['BUY', 'SELL'];
    
    function generateTrade() {
      const now = new Date();
      const isoTimestamp = now.toISOString();
      const instrument = instruments[Math.floor(Math.random() * instruments.length)];
      const side = sides[Math.floor(Math.random() * sides.length)];
      const timestamp = Date.now();
      
      const tradeId = `TRD-K6-${timestamp}-${Math.random().toString(36).substr(2, 9)}`;
      
      return {
        id: tradeId,
        trade_data: {
          tradeId: tradeId,
          exchangeTradeId: `EX-${timestamp}`,
          timestamp: isoTimestamp,
          executionTime: isoTimestamp,
          instrument: {
            symbol: instrument,
            type: instrument.includes('/') ? 'FX_SPOT' : 'EQUITY',
            exchange: 'TEST',
            currency: 'USD'
          },
          side: side,
          orderType: 'LIMIT',
          quantity: Math.floor(Math.random() * 10000) + 1000,
          price: Math.random() * 100 + 50,
          amount: Math.random() * 1000000,
          client: {
            id: `CLI-${Math.floor(Math.random() * 100)}`,
            account: `ACC-${Math.floor(Math.random() * 10)}`,
            type: 'INSTITUTIONAL'
          },
          metadata: {
            source: 'K6_TEST',
            version: '1.0',
            sequenceNumber: timestamp,
            latencyMs: Math.random() * 10
          }
        }
      };
    }
    
    export default function () {
      const db = sql.open(postgresDriver, connectionString);
      
      try {
        const trade = generateTrade();
        const tradeDataJson = JSON.stringify(trade.trade_data);
        
        const insertQuery = `
          INSERT INTO murex.trades (id, trade_data, created_at)
          VALUES ($1, $2::jsonb, NOW())
        `;
        
        const startTime = Date.now();
        
        try {
          db.exec(insertQuery, trade.id, tradeDataJson);
          
          const duration = Date.now() - startTime;
          insertDuration.add(duration);
          insertSuccessRate.add(true);
          insertsCount.add(1);
          
          check(null, {
            'trade inserted successfully': () => true,
          });
          
        } catch (execError) {
          const duration = Date.now() - startTime;
          insertDuration.add(duration);
          insertSuccessRate.add(false);
          errorsCount.add(1);
          
          console.error(`[VU ${__VU}] Insert failed: ${execError.message}`);
          
          check(null, {
            'trade inserted successfully': () => false,
          });
        }
        
      } catch (error) {
        errorsCount.add(1);
        insertSuccessRate.add(false);
        console.error(`[VU ${__VU}] Unexpected error: ${error.message}`);
      } finally {
        db.close();
      }
    }
    
    export function teardown() {
      console.log('Load test completed');
    }
```

## Ключевые особенности этого конфигурационного файла:

1. **Генерация данных**: Использует ту же логику генерации трейдов, что и в первом файле (Kafka producer)

2. **Прямая запись в PostgreSQL**: 
   - Открывает соединение с БД для каждой итерации
   - Выполняет INSERT напрямую в таблицу `murex.trades`
   - Использует параметризованный запрос для безопасности
   - Автоматически проставляет `created_at` через `NOW()`

3. **Метрики**:
   - `db_insert_success` - процент успешных вставок
   - `db_insert_duration` - время выполнения INSERT
   - `db_inserts_total` - общее количество вставок
   - `db_errors_total` - количество ошибок

4. **Профиль нагрузки**: Идентичен первому файлу (до 12000 операций/сек)

5. **Обработка ошибок**: 
   - Try-catch блоки для отлова ошибок БД
   - Логирование ошибок с номером VU
   - Закрытие соединений в finally блоке

6. **Пороговые значения (thresholds)**:
   - Успешность вставок > 95%
   - 95-й перцентиль длительности < 1 сек
   - 99-й перцентиль < 2 сек

**Примечание**: Замените `__DB_USERNAME__` и `__DB_PASSWORD__` на реальные учетные данные перед запуском теста.

















Отличные замечания! Вы абсолютно правы. Вот исправленная версия:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: k6-test-scripts
  labels:
    app: syngtp-k6-load-test-postgres-writer
data:
  test.js: |
    import { check, sleep } from 'k6';
    import { Rate, Trend, Counter } from 'k6/metrics';
    import sql from 'k6/x/sql';
    import postgresDriver from 'k6/x/sql/driver/postgres';
    
    // Custom metrics
    const insertSuccessRate = new Rate('db_insert_success');
    const insertDuration = new Trend('db_insert_duration');
    const insertsCount = new Counter('db_inserts_total');
    const errorsCount = new Counter('db_errors_total');
    
    // Test configuration
    export const options = {
      scenarios: {
        postgres_load: {
          executor: 'ramping-arrival-rate',
          startRate: 100,
          timeUnit: '1s',
          preAllocatedVUs: 50,
          maxVUs: 200,
          stages: [
            { duration: '10s', target: 1000 },
            { duration: '30s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '10s', target: 0 },
          ],
        },
      },
      thresholds: {
        'db_insert_success': ['rate>0.95'],
        'db_insert_duration': ['p(95)<1000', 'p(99)<2000'],
        'db_errors_total': ['count<1000'],
        'iteration_duration': ['p(95)<2000'],
      },
    };
    
    // Database configuration
    const dbUser = '__DB_USERNAME__';
    const dbPass = '__DB_PASSWORD__';
    const dbHost = 'tvled-kssh00010.esrt.sber.ru';
    const dbPort = '12541';
    const dbName = 'mr';
    
    // Connection string с параметрами для pgBouncer
    const connectionString = `host='${dbHost}' port='${dbPort}' user='${dbUser}' password='${dbPass}' dbname='${dbName}' sslmode='disable' search_path='murex' pool_max_conns=10 pool_min_conns=2 pool_max_conn_lifetime=3600s pool_max_conn_idle_time=1800s prepareThreshold=0`;
    
    // Sample instruments for variety
    const instruments = [
      'USD/RUB', 'EUR/USD', 'GBP/USD', 'USD/JPY',
      'BTC/USD', 'ETH/USD', 'SBER', 'GAZP'
    ];
    
    const sides = ['BUY', 'SELL'];
    
    // Global connection pool (one per VU)
    let db = null;
    
    function generateTrade() {
      const now = new Date();
      const isoTimestamp = now.toISOString();
      const instrument = instruments[Math.floor(Math.random() * instruments.length)];
      const side = sides[Math.floor(Math.random() * sides.length)];
      const timestamp = Date.now();
      
      const tradeId = `TRD-K6-${timestamp}-${Math.random().toString(36).substr(2, 9)}`;
      
      return {
        id: tradeId,
        trade_data: {
          tradeId: tradeId,
          exchangeTradeId: `EX-${timestamp}`,
          timestamp: isoTimestamp,
          executionTime: isoTimestamp,
          instrument: {
            symbol: instrument,
            type: instrument.includes('/') ? 'FX_SPOT' : 'EQUITY',
            exchange: 'TEST',
            currency: 'USD'
          },
          side: side,
          orderType: 'LIMIT',
          quantity: Math.floor(Math.random() * 10000) + 1000,
          price: Math.random() * 100 + 50,
          amount: Math.random() * 1000000,
          client: {
            id: `CLI-${Math.floor(Math.random() * 100)}`,
            account: `ACC-${Math.floor(Math.random() * 10)}`,
            type: 'INSTITUTIONAL'
          },
          metadata: {
            source: 'K6_TEST',
            version: '1.0',
            sequenceNumber: timestamp,
            latencyMs: Math.random() * 10
          }
        }
      };
    }
    
    export function setup() {
      // Verify connection at start
      const testDb = sql.open(postgresDriver, connectionString);
      try {
        testDb.exec('SELECT 1');
        console.log('Database connection verified successfully');
      } catch (error) {
        console.error('Failed to connect to database:', error.message);
        throw error;
      } finally {
        testDb.close();
      }
    }
    
    export default function () {
      // Initialize connection pool once per VU
      if (db === null) {
        try {
          db = sql.open(postgresDriver, connectionString);
          console.log(`[VU ${__VU}] Connection pool initialized`);
        } catch (error) {
          console.error(`[VU ${__VU}] Failed to initialize connection pool: ${error.message}`);
          errorsCount.add(1);
          insertSuccessRate.add(false);
          return;
        }
      }
      
      try {
        const trade = generateTrade();
        const tradeDataJson = JSON.stringify(trade.trade_data);
        
        // Simple INSERT without prepared statements (для pgBouncer с prepareThreshold=0)
        const insertQuery = `
          INSERT INTO murex.trades (id, trade_data, created_at)
          VALUES ('${trade.id}', '${tradeDataJson.replace(/'/g, "''")}'::jsonb, NOW())
        `;
        
        const startTime = Date.now();
        
        try {
          db.exec(insertQuery);
          
          const duration = Date.now() - startTime;
          insertDuration.add(duration);
          insertSuccessRate.add(true);
          insertsCount.add(1);
          
          check(null, {
            'trade inserted successfully': () => true,
          });
          
        } catch (execError) {
          const duration = Date.now() - startTime;
          insertDuration.add(duration);
          insertSuccessRate.add(false);
          errorsCount.add(1);
          
          console.error(`[VU ${__VU}] Insert failed: ${execError.message}`);
          
          check(null, {
            'trade inserted successfully': () => false,
          });
          
          // При ошибке соединения пытаемся переподключиться
          if (execError.message.includes('connection') || execError.message.includes('closed')) {
            console.log(`[VU ${__VU}] Attempting to reconnect...`);
            try {
              db.close();
            } catch (e) {
              // Ignore close errors
            }
            db = null;
          }
        }
        
      } catch (error) {
        errorsCount.add(1);
        insertSuccessRate.add(false);
        console.error(`[VU ${__VU}] Unexpected error: ${error.message}`);
      }
    }
    
    export function teardown() {
      if (db !== null) {
        try {
          db.close();
          console.log('Connection pool closed');
        } catch (error) {
          console.error('Error closing connection pool:', error.message);
        }
      }
      console.log('Load test completed');
    }
```

## Ключевые изменения:

1. **Connection Pool**: 
   - Соединение создается один раз для каждого VU и переиспользуется
   - Параметры пула: `pool_max_conns=10`, `pool_min_conns=2`
   - Соединение закрывается только в `teardown()`

2. **PgBouncer совместимость**:
   - Добавлен параметр `prepareThreshold=0` в connection string
   - Вместо параметризованных запросов используется обычный INSERT с экранированием одинарных кавычек
   - Это критично для работы через PgBouncer в transaction pooling режиме

3. **Переподключение при ошибках**:
   - Если возникает ошибка соединения, пытаемся переподключиться
   - Обнуляем `db` чтобы в следующей итерации создать новое соединение

4. **Верификация подключения**:
   - В `setup()` проверяем возможность подключения к БД перед началом теста

Такой подход существенно снизит нагрузку на установку соединений и будет корректно работать с pgBouncer в режиме transaction pooling.



_------_-------------
Вы абсолютно правы! `prepareThreshold=0` - это параметр JDBC драйвера для Java приложений. 

Для K6 с драйвером `k6/x/sql/driver/postgres` (который использует Go драйвер `pq` или `pgx`) этот параметр не применим.

Для работы с pgBouncer в Go драйверах нужно использовать другие параметры или вообще обойтись без них. Вот исправленная версия:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: k6-test-scripts
  labels:
    app: syngtp-k6-load-test-postgres-writer
data:
  test.js: |
    import { check, sleep } from 'k6';
    import { Rate, Trend, Counter } from 'k6/metrics';
    import sql from 'k6/x/sql';
    import postgresDriver from 'k6/x/sql/driver/postgres';
    
    // Custom metrics
    const insertSuccessRate = new Rate('db_insert_success');
    const insertDuration = new Trend('db_insert_duration');
    const insertsCount = new Counter('db_inserts_total');
    const errorsCount = new Counter('db_errors_total');
    
    // Test configuration
    export const options = {
      scenarios: {
        postgres_load: {
          executor: 'ramping-arrival-rate',
          startRate: 100,
          timeUnit: '1s',
          preAllocatedVUs: 50,
          maxVUs: 200,
          stages: [
            { duration: '10s', target: 1000 },
            { duration: '30s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '60s', target: 12000 },
            { duration: '10s', target: 0 },
          ],
        },
      },
      thresholds: {
        'db_insert_success': ['rate>0.95'],
        'db_insert_duration': ['p(95)<1000', 'p(99)<2000'],
        'db_errors_total': ['count<1000'],
        'iteration_duration': ['p(95)<2000'],
      },
    };
    
    // Database configuration
    const dbUser = '__DB_USERNAME__';
    const dbPass = '__DB_PASSWORD__';
    const dbHost = 'tvled-kssh00010.esrt.sber.ru';
    const dbPort = '12541';
    const dbName = 'mr';
    
    // Connection string для работы с pgBouncer
    // statement_cache_mode=describe - отключает prepared statements (аналог prepareThreshold=0 в JDBC)
    // или можно использовать prefer_simple_protocol=true
    const connectionString = `postgres://${dbUser}:${dbPass}@${dbHost}:${dbPort}/${dbName}?sslmode=disable&search_path=murex&statement_cache_mode=describe`;
    
    // Sample instruments for variety
    const instruments = [
      'USD/RUB', 'EUR/USD', 'GBP/USD', 'USD/JPY',
      'BTC/USD', 'ETH/USD', 'SBER', 'GAZP'
    ];
    
    const sides = ['BUY', 'SELL'];
    
    // Global connection pool (one per VU)
    let db = null;
    
    function generateTrade() {
      const now = new Date();
      const isoTimestamp = now.toISOString();
      const instrument = instruments[Math.floor(Math.random() * instruments.length)];
      const side = sides[Math.floor(Math.random() * sides.length)];
      const timestamp = Date.now();
      
      const tradeId = `TRD-K6-${timestamp}-${Math.random().toString(36).substr(2, 9)}`;
      
      return {
        id: tradeId,
        trade_data: {
          tradeId: tradeId,
          exchangeTradeId: `EX-${timestamp}`,
          timestamp: isoTimestamp,
          executionTime: isoTimestamp,
          instrument: {
            symbol: instrument,
            type: instrument.includes('/') ? 'FX_SPOT' : 'EQUITY',
            exchange: 'TEST',
            currency: 'USD'
          },
          side: side,
          orderType: 'LIMIT',
          quantity: Math.floor(Math.random() * 10000) + 1000,
          price: Math.random() * 100 + 50,
          amount: Math.random() * 1000000,
          client: {
            id: `CLI-${Math.floor(Math.random() * 100)}`,
            account: `ACC-${Math.floor(Math.random() * 10)}`,
            type: 'INSTITUTIONAL'
          },
          metadata: {
            source: 'K6_TEST',
            version: '1.0',
            sequenceNumber: timestamp,
            latencyMs: Math.random() * 10
          }
        }
      };
    }
    
    export function setup() {
      // Verify connection at start
      const testDb = sql.open(postgresDriver, connectionString);
      try {
        testDb.exec('SELECT 1');
        console.log('Database connection verified successfully');
      } catch (error) {
        console.error('Failed to connect to database:', error.message);
        throw error;
      } finally {
        testDb.close();
      }
    }
    
    export default function () {
      // Initialize connection pool once per VU
      if (db === null) {
        try {
          db = sql.open(postgresDriver, connectionString);
          console.log(`[VU ${__VU}] Connection pool initialized`);
        } catch (error) {
          console.error(`[VU ${__VU}] Failed to initialize connection pool: ${error.message}`);
          errorsCount.add(1);
          insertSuccessRate.add(false);
          return;
        }
      }
      
      try {
        const trade = generateTrade();
        const tradeDataJson = JSON.stringify(trade.trade_data);
        
        // Используем параметризованный запрос с $1, $2
        // Благодаря statement_cache_mode=describe это будет работать через pgBouncer
        const insertQuery = `
          INSERT INTO murex.trades (id, trade_data, created_at)
          VALUES ($1, $2::jsonb, NOW())
        `;
        
        const startTime = Date.now();
        
        try {
          db.exec(insertQuery, trade.id, tradeDataJson);
          
          const duration = Date.now() - startTime;
          insertDuration.add(duration);
          insertSuccessRate.add(true);
          insertsCount.add(1);
          
          check(null, {
            'trade inserted successfully': () => true,
          });
          
        } catch (execError) {
          const duration = Date.now() - startTime;
          insertDuration.add(duration);
          insertSuccessRate.add(false);
          errorsCount.add(1);
          
          console.error(`[VU ${__VU}] Insert failed: ${execError.message}`);
          
          check(null, {
            'trade inserted successfully': () => false,
          });
          
          // При ошибке соединения пытаемся переподключиться
          if (execError.message.includes('connection') || execError.message.includes('closed')) {
            console.log(`[VU ${__VU}] Attempting to reconnect...`);
            try {
              db.close();
            } catch (e) {
              // Ignore close errors
            }
            db = null;
          }
        }
        
      } catch (error) {
        errorsCount.add(1);
        insertSuccessRate.add(false);
        console.error(`[VU ${__VU}] Unexpected error: ${error.message}`);
      }
    }
    
    export function teardown() {
      if (db !== null) {
        try {
          db.close();
          console.log('Connection pool closed');
        } catch (error) {
          console.error('Error closing connection pool:', error.message);
        }
      }
      console.log('Load test completed');
    }
```

## Ключевое изменение:

**Connection string** теперь использует правильный параметр для Go драйвера:
- `statement_cache_mode=describe` - это аналог `prepareThreshold=0` для pgx драйвера
- Этот параметр отключает кеширование prepared statements, что критично для работы с pgBouncer в transaction pooling режиме

Альтернативный вариант connection string (если первый не сработает):
```javascript
const connectionString = `postgres://${dbUser}:${dbPass}@${dbHost}:${dbPort}/${dbName}?sslmode=disable&search_path=murex&prefer_simple_protocol=true`;
```

Параметр `prefer_simple_protocol=true` также отключает prepared statements и использует simple query protocol, что полностью совместимо с pgBouncer.
