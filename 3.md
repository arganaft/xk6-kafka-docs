Это интересная и комплексная задача. Учитывая спецификацию AsyncAPI и требования (Java 21, Spring Boot, Virtual Threads, STOMP/WebSocket), я спроектирую архитектуру следующим образом:

1.  **Протокол:** Мы будем использовать **STOMP over WebSocket**. Спецификация описывает каналы `/app/trades` и `/topic/trades`, что является стандартным паттерном для Spring STOMP.
2.  **Виртуальные потоки:** Включим их в конфигурации для высокой производительности при большом количестве соединений.
3.  **Архитектура данных:**
    *   **ClientController:** Обрабатывает запросы от Frontend (подписки).
    *   **IngestController:** Отдельный WebSocket endpoint для приема "сырых" данных от внешних источников.
    *   **SubscriptionManager:** Хранит состояние подписок (фильтры, пагинация) для каждой сессии.
    *   **DataProcessor:** "Сердце" системы. Принимает данные, пробегается по активным подпискам, фильтрует данные и отправляет их конкретным клиентам.

Ниже приведен полный код решения.

### 1. Настройка проекта (pom.xml)

Вам понадобятся следующие зависимости:

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-websocket</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-json</artifactId>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
```

### 2. Конфигурация (application.yml)

Включаем виртуальные потоки и настройку генератора данных.

```yaml
spring:
  application:
    name: trade-websocket-api
  threads:
    virtual:
      enabled: true # Java 21 Virtual Threads

app:
  mock-data:
    enabled: true # true - генерируем данные, false - ждем извне
    interval-ms: 1000
```

### 3. Модели данных (DTO)

Создадим классы на основе схем из вашего YAML.

```java
package com.example.trade.model;

import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

// --- Входящие сообщения от клиента ---

@Data
@NoArgsConstructor
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "type")
@JsonSubTypes({
    @JsonSubTypes.Type(value = SetViewConfigurationRequest.class, name = "SetViewConfiguration"),
    @JsonSubTypes.Type(value = RequestImmediateDataRequest.class, name = "RequestImmediateData"),
    @JsonSubTypes.Type(value = GetCurrentConfigRequest.class, name = "GetCurrentConfig")
})
public abstract class ClientRequest {
    private String type;
}

@Data
public class SetViewConfigurationRequest extends ClientRequest {
    private StreamViewConfig data;
}

@Data
public class RequestImmediateDataRequest extends ClientRequest {
    private StreamViewConfig data;
}

@Data
public class GetCurrentConfigRequest extends ClientRequest {
    private String requestId;
}

// --- Конфигурация (StreamViewConfig) ---

@Data
@JsonIgnoreProperties(ignoreUnknown = true)
public class StreamViewConfig {
    private int startRow;
    private int endRow;
    private String requestId;
    private String clientId;
    private List<GridColumn> columns = new ArrayList<>();
    private Map<String, Object> filterModel = new HashMap<>();
    private List<SortModel> sortModel = new ArrayList<>();
    // Остальные поля опущены для краткости, но должны быть тут
}

@Data
public class GridColumn {
    private int id;
    private String fieldKey;
    private String name;
    private String dataType;
}

@Data
public class SortModel {
    private String colId;
    private String sort; // asc, desc
}

// --- Исходящие сообщения (События) ---

@Data
@AllArgsConstructor
public class ServerEvent {
    private String type;
    private Object payload; // В реальном коде лучше типизировать, но для гибкости Object
}

@Data
@AllArgsConstructor
@NoArgsConstructor
public class TradeResponse {
    private String type; // ReceiveData, ReceiveImmediateData
    private boolean success;
    private List<Map<String, Object>> rows;
    private int lastRow;
    private String requestId;
    private String error;
}

@Data
@AllArgsConstructor
public class ConnectedEvent {
    private String type = "Connected";
    private String clientId;
}

@Data
@AllArgsConstructor
public class ConfigurationUpdatedEvent {
    private String type = "ConfigurationUpdated";
    private StreamViewConfig config;
    private String timestamp;
}

// --- Модель данных сделки (внутренняя) ---
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Trade {
    private String symbol;
    private double price;
    private long volume;
    private String timestamp;
    
    // Метод для конвертации в Map для отправки
    @JsonAnySetter
    public Map<String, Object> toMap() {
        Map<String, Object> map = new HashMap<>();
        map.put("symbol", symbol);
        map.put("price", price);
        map.put("volume", volume);
        map.put("timestamp", timestamp);
        return map;
    }
}
```

### 4. Конфигурация WebSocket (STOMP и Raw)

Нам нужно два эндпоинта:
1. `/ws` (STOMP) для Frontend клиентов.
2. `/ws-ingest` (Raw WebSocket) для поставщиков данных.

```java
package com.example.trade.config;

import com.example.trade.controller.DataIngestHandler;
import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.*;

@Configuration
@EnableWebSocketMessageBroker
@EnableWebSocket
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer, WebSocketConfigurer {

    private final DataIngestHandler dataIngestHandler;

    public WebSocketConfig(DataIngestHandler dataIngestHandler) {
        this.dataIngestHandler = dataIngestHandler;
    }

    // 1. Конфигурация STOMP для Frontend
    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws")
                .setAllowedOriginPatterns("*"); // Разрешаем CORS
                // .withSockJS(); // Можно включить если нужен фоллбек
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        // Клиент отправляет в /app/trades
        registry.setApplicationDestinationPrefixes("/app");
        // Сервер отправляет в /topic/trades (используем user destinations для приватности)
        registry.enableSimpleBroker("/topic", "/queue");
        registry.setUserDestinationPrefix("/user");
    }

    // 2. Конфигурация Raw WebSocket для входящего потока данных
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(dataIngestHandler, "/ws-ingest")
                .setAllowedOriginPatterns("*");
    }
}
```

### 5. Сервис управления подписками и обработки данных

Это ядро логики. Здесь мы храним, что хочет каждый клиент, и фильтруем входящие данные.

```java
package com.example.trade.service;

import com.example.trade.model.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

@Service
@Slf4j
@RequiredArgsConstructor
public class TradeService {

    private final SimpMessagingTemplate messagingTemplate;
    
    // Map<SessionId, List<Config>> - один клиент может иметь несколько подписок
    private final Map<String, List<StreamViewConfig>> clientSubscriptions = new ConcurrentHashMap<>();

    public void addSubscription(String sessionId, StreamViewConfig config) {
        clientSubscriptions.computeIfAbsent(sessionId, k -> new ArrayList<>()).add(config);
        
        // Отправляем подтверждение
        ConfigurationUpdatedEvent event = new ConfigurationUpdatedEvent(
                "ConfigurationUpdated", 
                config, 
                Instant.now().toString()
        );
        sendToUser(sessionId, event);
        
        // Сразу отправляем RequestImmediateData если это был запрос (упрощение логики)
        // В реальном приложении здесь может быть выборка из БД исторических данных
    }

    public void removeSession(String sessionId) {
        clientSubscriptions.remove(sessionId);
    }

    public List<StreamViewConfig> getConfigs(String sessionId) {
        return clientSubscriptions.getOrDefault(sessionId, Collections.emptyList());
    }

    /**
     * Метод обработки входящего потока данных (от Mock или Ingest)
     */
    public void processIncomingData(List<Trade> trades) {
        // Запускаем обработку в виртуальном потоке для каждого клиента, если их много
        clientSubscriptions.forEach((sessionId, configs) -> {
            for (StreamViewConfig config : configs) {
                List<Map<String, Object>> filteredRows = applyConfigToData(trades, config);
                
                if (!filteredRows.isEmpty()) {
                    TradeResponse response = new TradeResponse(
                            "ReceiveData",
                            true,
                            filteredRows,
                            10000, // Mock total rows
                            config.getRequestId(),
                            null
                    );
                    sendToUser(sessionId, response);
                }
            }
        });
    }

    private void sendToUser(String sessionId, Object payload) {
        // Отправляем в личную очередь пользователя. 
        // Frontend должен подписаться на /user/topic/trades или /user/queue/trades
        // Spring преобразует это в /topic/trades-user<SessionID>
        messagingTemplate.convertAndSendToUser(sessionId, "/topic/trades", payload);
    }

    // Упрощенная логика фильтрации и пагинации
    private List<Map<String, Object>> applyConfigToData(List<Trade> trades, StreamViewConfig config) {
        return trades.stream()
                // 1. Фильтрация (пример для поля symbol)
                .filter(trade -> {
                    if (config.getFilterModel() != null && config.getFilterModel().containsKey("symbol")) {
                        // Здесь должна быть сложная логика разбора filterModel из AG Grid
                        // Для примера: пропускаем всё
                        return true; 
                    }
                    return true;
                })
                // 2. Сортировка (пропущена для краткости)
                // 3. Пагинация (очень условно для потоковых данных)
                // В реальном стриминге пагинация работает иначе (окно просмотра), 
                // но здесь мы просто отдаем данные, если они попадают в "окно" интереса, 
                // или просто отдаем всё, что пришло, если это обновление.
                .map(Trade::toMap)
                .collect(Collectors.toList());
    }
}
```

### 6. Контроллер для Frontend (STOMP)

```java
package com.example.trade.controller;

import com.example.trade.model.*;
import com.example.trade.service.TradeService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.event.EventListener;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.messaging.simp.SimpMessageHeaderAccessor;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.messaging.simp.stomp.StompHeaderAccessor;
import org.springframework.stereotype.Controller;
import org.springframework.web.socket.messaging.SessionConnectEvent;
import org.springframework.web.socket.messaging.SessionDisconnectEvent;

import java.util.UUID;

@Controller
@RequiredArgsConstructor
@Slf4j
public class TradeClientController {

    private final TradeService tradeService;
    private final SimpMessagingTemplate messagingTemplate;

    // Обработка подключения
    @EventListener
    public void handleWebSocketConnectListener(SessionConnectEvent event) {
        StompHeaderAccessor headerAccessor = StompHeaderAccessor.wrap(event.getMessage());
        String sessionId = headerAccessor.getSessionId();
        String clientId = "client-" + UUID.randomUUID();
        
        // Сохраняем clientId в атрибуты сессии, если нужно
        headerAccessor.getSessionAttributes().put("clientId", clientId);

        log.info("New connection: {}, ClientID: {}", sessionId, clientId);

        // Отправляем событие Connected
        ConnectedEvent connectedEvent = new ConnectedEvent("Connected", clientId);
        messagingTemplate.convertAndSendToUser(sessionId, "/topic/trades", connectedEvent);
    }

    // Обработка отключения
    @EventListener
    public void handleWebSocketDisconnectListener(SessionDisconnectEvent event) {
        String sessionId = event.getSessionId();
        tradeService.removeSession(sessionId);
        log.info("Disconnected: {}", sessionId);
    }

    // Единая точка входа для сообщений в /app/trades
    @MessageMapping("/trades")
    public void handleClientRequest(@Payload ClientRequest request, SimpMessageHeaderAccessor headerAccessor) {
        String sessionId = headerAccessor.getSessionId();
        String clientId = (String) headerAccessor.getSessionAttributes().get("clientId");

        log.info("Received request type: {} from {}", request.getType(), sessionId);

        if (request instanceof SetViewConfigurationRequest setConfig) {
            StreamViewConfig config = setConfig.getData();
            config.setClientId(clientId); // Принудительно ставим ID
            tradeService.addSubscription(sessionId, config);
        } 
        else if (request instanceof RequestImmediateDataRequest reqData) {
            // Логика для немедленного запроса (можно переиспользовать логику подписки или сделать разовую выборку)
            // Для примера просто логируем
            log.info("Immediate data requested for reqId: {}", reqData.getData().getRequestId());
        }
        else if (request instanceof GetCurrentConfigRequest) {
            // Отправка текущей конфигурации
            var configs = tradeService.getConfigs(sessionId);
            if (!configs.isEmpty()) {
                // Берем последнюю или отправляем список (по спеке вроде одна активная, но мы храним список)
                StreamViewConfig lastConfig = configs.getLast();
                messagingTemplate.convertAndSendToUser(sessionId, "/topic/trades", 
                    new ServerEvent("CurrentConfig", lastConfig));
            }
        }
    }
}
```

### 7. Контроллер для Входного потока (Raw WebSocket)

Этот класс принимает JSON массив сделок от внешнего источника.

```java
package com.example.trade.controller;

import com.example.trade.model.Trade;
import com.example.trade.service.TradeService;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;

import java.util.List;

@Component
@Slf4j
@RequiredArgsConstructor
public class DataIngestHandler extends TextWebSocketHandler {

    private final TradeService tradeService;
    private final ObjectMapper objectMapper;

    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        try {
            // Ожидаем массив сделок: [{"symbol": "AAPL", "price": 100, ...}, ...]
            List<Trade> trades = objectMapper.readValue(message.getPayload(), new TypeReference<List<Trade>>() {});
            
            // Отправляем в сервис обработки
            tradeService.processIncomingData(trades);
            
        } catch (Exception e) {
            log.error("Error parsing incoming data: {}", e.getMessage());
        }
    }
}
```

### 8. Генератор тестовых данных (Mock)

Работает только если `app.mock-data.enabled=true`.

```java
package com.example.trade.service;

import com.example.trade.model.Trade;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

@Service
@Slf4j
@EnableScheduling
@RequiredArgsConstructor
@ConditionalOnProperty(name = "app.mock-data.enabled", havingValue = "true", matchIfMissing = false)
public class MockDataGenerator {

    private final TradeService tradeService;
    private final Random random = new Random();
    private final String[] symbols = {"AAPL", "GOOGL", "MSFT", "AMZN", "TSLA", "BTC-USD"};

    @Scheduled(fixedRateString = "${app.mock-data.interval-ms:1000}")
    public void generateData() {
        List<Trade> trades = new ArrayList<>();
        int count = random.nextInt(5) + 1; // 1-5 сделок за раз

        for (int i = 0; i < count; i++) {
            String symbol = symbols[random.nextInt(symbols.length)];
            double price = 100 + (random.nextDouble() * 500);
            long volume = random.nextInt(10000);
            
            trades.add(new Trade(
                symbol, 
                Math.round(price * 100.0) / 100.0, 
                volume, 
                Instant.now().toString()
            ));
        }

        log.debug("Generated {} mock trades", trades.size());
        tradeService.processIncomingData(trades);
    }
}
```

### Как это работает:

1.  **Запуск:** Приложение стартует. Если в `application.yml` включен mock, `MockDataGenerator` начинает генерировать сделки каждую секунду.
2.  **Подключение клиента:** Frontend подключается по WS к `ws://localhost:8080/ws`.
    *   Срабатывает `handleWebSocketConnectListener`.
    *   Клиент получает сообщение `Connected` с `clientId`.
    *   Клиент подписывается на `/user/topic/trades`.
3.  **Подписка:** Frontend отправляет JSON `SetViewConfiguration` в `/app/trades`.
    *   `TradeClientController` десериализует JSON в `SetViewConfigurationRequest`.
    *   Вызывается `tradeService.addSubscription`.
    *   Клиент получает подтверждение `ConfigurationUpdated`.
4.  **Поток данных:**
    *   **Вариант А (Mock):** Генератор создает список `Trade` и вызывает `tradeService.processIncomingData`.
    *   **Вариант Б (Внешний источник):** Внешний скрипт подключается к `ws://localhost:8080/ws-ingest` и шлет JSON массив сделок. `DataIngestHandler` передает их в сервис.
5.  **Рассылка:** `TradeService` берет данные, проверяет подписки (фильтры) и через `SimpMessagingTemplate` отправляет сообщение `ReceiveData` только тем пользователям, чьим фильтрам соответствуют данные.

### Важные замечания по реализации:

1.  **User Destinations:** В Spring STOMP, когда вы отправляете `convertAndSendToUser(sessionId, "/topic/trades", ...)`, клиент на фронтенде должен подписываться на `/user/topic/trades`. Spring автоматически транслирует это в уникальную очередь для этой сессии. Это критично для того, чтобы разные клиенты получали разные данные (отфильтрованные под них).
2.  **Полиморфизм JSON:** Класс `ClientRequest` использует аннотации Jackson для определения типа сообщения на основе поля `type`. Это
