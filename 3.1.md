Эта ошибка возникает из-за **циклической зависимости (Circular Dependency)**.

### Суть проблемы
1. Spring пытается создать `WebSocketConfig`.
2. Для этого ему нужен `DataIngestHandler`.
3. Для `DataIngestHandler` нужен `TradeService`.
4. Для `TradeService` нужен `SimpMessagingTemplate` (чтобы отправлять сообщения).
5. Но `SimpMessagingTemplate` создается и настраивается внутри инфраструктуры WebSocket, которую конфигурирует... `WebSocketConfig` (пункт 1).

Получается замкнутый круг: конфигурация не может завершиться, пока не создан сервис, а сервис не может создаться, пока не готова конфигурация.

### Решение

Самый надежный и правильный способ разорвать этот круг в Spring Boot — использовать аннотацию **`@Lazy`** при внедрении зависимости `SimpMessagingTemplate`. Это скажет Spring'у: "Создай `TradeService` сейчас, а `SimpMessagingTemplate` внедри потом, когда он понадобится (подставь прокси)".

Вам нужно изменить класс `TradeService`. Так как вы используете Lombok (`@RequiredArgsConstructor`), у вас два пути: либо настроить Lombok, либо (что проще и нагляднее) написать конструктор вручную.

Вот исправленный класс `TradeService`:

```java
package com.example.trade.service;

import com.example.trade.model.*;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Lazy;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

@Service
@Slf4j
public class TradeService {

    private final SimpMessagingTemplate messagingTemplate;
    
    // Map<SessionId, List<Config>>
    private final Map<String, List<StreamViewConfig>> clientSubscriptions = new ConcurrentHashMap<>();

    // МЫ УБРАЛИ @RequiredArgsConstructor И НАПИСАЛИ КОНСТРУКТОР ВРУЧНУЮ
    // Добавили @Lazy перед SimpMessagingTemplate
    public TradeService(@Lazy SimpMessagingTemplate messagingTemplate) {
        this.messagingTemplate = messagingTemplate;
    }

    public void addSubscription(String sessionId, StreamViewConfig config) {
        clientSubscriptions.computeIfAbsent(sessionId, k -> new ArrayList<>()).add(config);
        
        ConfigurationUpdatedEvent event = new ConfigurationUpdatedEvent(
                "ConfigurationUpdated", 
                config, 
                Instant.now().toString()
        );
        sendToUser(sessionId, event);
    }

    public void removeSession(String sessionId) {
        clientSubscriptions.remove(sessionId);
    }

    public List<StreamViewConfig> getConfigs(String sessionId) {
        return clientSubscriptions.getOrDefault(sessionId, Collections.emptyList());
    }

    public void processIncomingData(List<Trade> trades) {
        clientSubscriptions.forEach((sessionId, configs) -> {
            for (StreamViewConfig config : configs) {
                List<Map<String, Object>> filteredRows = applyConfigToData(trades, config);
                
                if (!filteredRows.isEmpty()) {
                    TradeResponse response = new TradeResponse(
                            "ReceiveData",
                            true,
                            filteredRows,
                            10000, 
                            config.getRequestId(),
                            null
                    );
                    sendToUser(sessionId, response);
                }
            }
        });
    }

    private void sendToUser(String sessionId, Object payload) {
        messagingTemplate.convertAndSendToUser(sessionId, "/topic/trades", payload);
    }

    private List<Map<String, Object>> applyConfigToData(List<Trade> trades, StreamViewConfig config) {
        return trades.stream()
                .filter(trade -> true) // Упрощенный фильтр
                .map(Trade::toMap)
                .collect(Collectors.toList());
    }
}
```

### Альтернативный вариант (если очень хочется оставить Lombok)

Если вы хотите оставить аннотацию `@RequiredArgsConstructor`, вам нужно создать файл `lombok.config` в корне проекта (или в папке src/main/java) с содержимым `lombok.copyableAnnotations += org.springframework.context.annotation.Lazy`, а затем использовать такой синтаксис:

```java
@Service
@Slf4j
@RequiredArgsConstructor(onConstructor_ = {@Lazy}) // Это применит Lazy ко всем аргументам, что не всегда хорошо
public class TradeService { ... }
```
*Но лучше используйте явный конструктор, как показано в основном решении выше — это безопаснее и понятнее.*

После применения изменения с `@Lazy` приложение должно успешно запуститься.
