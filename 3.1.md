# Проблема с `convertAndSendToUser`

## Корень проблемы

Метод `convertAndSendToUser(sessionId, destination, payload)` работает **не с sessionId**, а с **именем пользователя (Principal)**. Когда вы передаёте `sessionId` как первый аргумент, Spring ищет пользователя с таким именем, не находит и сообщение уходит "в никуда".

## Как Spring резолвит user destinations

Когда клиент подписывается на `/user/topic/trades`, Spring преобразует это в:

```
/user/{userName}/topic/trades  →  /topic/trades-user{sessionId}
```

Но если у вас **нет аутентификации** (нет `Principal`), Spring не знает, кто этот "user".

## Решение 1: Использовать `convertAndSendToUser` с sessionId через заголовки

```java
@Controller
@RequiredArgsConstructor
@Slf4j
public class TradeClientController {

    private final TradeService tradeService;
    private final SimpMessagingTemplate messagingTemplate;

    @EventListener
    public void handleWebSocketConnectListener(SessionConnectEvent event) {
        StompHeaderAccessor headerAccessor = StompHeaderAccessor.wrap(event.getMessage());
        String sessionId = headerAccessor.getSessionId();
        String clientId = "client-" + UUID.randomUUID();

        headerAccessor.getSessionAttributes().put("clientId", clientId);

        log.info("New connection: {}, ClientID: {}", sessionId, clientId);

        // Правильный способ отправки по sessionId без Principal
        ConnectedEvent connectedEvent = new ConnectedEvent("Connected", clientId);
        sendToSession(sessionId, "/topic/trades", connectedEvent);
    }

    @EventListener
    public void handleWebSocketDisconnectListener(SessionDisconnectEvent event) {
        String sessionId = event.getSessionId();
        tradeService.removeSession(sessionId);
        log.info("Disconnected: {}", sessionId);
    }

    @MessageMapping("/config")
    public void handleClientRequest(@Payload ClientRequest request, 
                                     SimpMessageHeaderAccessor headerAccessor) {
        String sessionId = headerAccessor.getSessionId();
        String clientId = (String) headerAccessor.getSessionAttributes().get("clientId");
        log.info("Received message sessionId: {}, clientId: {}, request: {}", 
                 sessionId, clientId, request);

        // Отправляем ответ в сессию
        sendToSession(sessionId, "/topic/trades", "Config received for " + clientId);
    }

    /**
     * Отправка сообщения конкретной сессии через user destination + sessionId header
     */
    private void sendToSession(String sessionId, String destination, Object payload) {
        SimpMessageHeaderAccessor headerAccessor = SimpMessageHeaderAccessor.create();
        headerAccessor.setSessionId(sessionId);
        headerAccessor.setLeaveMutable(true);

        messagingTemplate.convertAndSendToUser(
                sessionId,           // sessionId как "user"
                destination,
                payload,
                headerAccessor.getMessageHeaders()
        );
    }
}
```

## Решение 2 (рекомендуемое): Назначить Principal при подключении

Создайте интерцептор, который назначает `Principal` каждой сессии:

```java
package com.websocket.trade.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.http.server.ServerHttpRequest;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.WebSocketHandler;
import org.springframework.web.socket.config.annotation.*;
import org.springframework.web.socket.server.support.DefaultHandshakeHandler;

import java.security.Principal;
import java.util.Map;
import java.util.UUID;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws")
                .setHandshakeHandler(new CustomHandshakeHandler())
                .setAllowedOriginPatterns("*");
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.setApplicationDestinationPrefixes("/app");
        registry.enableSimpleBroker("/topic", "/queue");
        registry.setUserDestinationPrefix("/user");
    }
}
```

```java
package com.websocket.trade.config;

import org.springframework.http.server.ServerHttpRequest;
import org.springframework.web.socket.WebSocketHandler;
import org.springframework.web.socket.server.support.DefaultHandshakeHandler;

import java.security.Principal;
import java.util.Map;
import java.util.UUID;

public class CustomHandshakeHandler extends DefaultHandshakeHandler {

    @Override
    protected Principal determineUser(ServerHttpRequest request,
                                       WebSocketHandler wsHandler,
                                       Map<String, Object> attributes) {
        // Генерируем уникальный Principal для каждого подключения
        String uniqueId = UUID.randomUUID().toString();
        return new StompPrincipal(uniqueId);
    }
}
```

```java
package com.websocket.trade.config;

import java.security.Principal;

public class StompPrincipal implements Principal {

    private final String name;

    public StompPrincipal(String name) {
        this.name = name;
    }

    @Override
    public String getName() {
        return name;
    }
}
```

Теперь контроллер использует `Principal`:

```java
@Controller
@RequiredArgsConstructor
@Slf4j
public class TradeClientController {

    private final TradeService tradeService;
    private final SimpMessagingTemplate messagingTemplate;

    @EventListener
    public void handleWebSocketConnectListener(SessionConnectEvent event) {
        StompHeaderAccessor headerAccessor = StompHeaderAccessor.wrap(event.getMessage());
        String sessionId = headerAccessor.getSessionId();
        
        // Principal теперь доступен
        Principal principal = headerAccessor.getUser();
        String userName = principal != null ? principal.getName() : "unknown";

        log.info("New connection: session={}, user={}", sessionId, userName);

        // Теперь convertAndSendToUser работает корректно!
        ConnectedEvent connectedEvent = new ConnectedEvent("Connected", userName);
        messagingTemplate.convertAndSendToUser(userName, "/topic/trades", connectedEvent);
    }

    @EventListener
    public void handleWebSocketDisconnectListener(SessionDisconnectEvent event) {
        String sessionId = event.getSessionId();
        tradeService.removeSession(sessionId);
        log.info("Disconnected: {}", sessionId);
    }

    @MessageMapping("/config")
    public void handleClientRequest(@Payload ClientRequest request,
                                     SimpMessageHeaderAccessor headerAccessor) {
        String sessionId = headerAccessor.getSessionId();
        Principal principal = headerAccessor.getUser();
        String userName = principal != null ? principal.getName() : "unknown";

        log.info("Received config from user={}, session={}, request={}", 
                 userName, sessionId, request);

        // Отправляем ответ конкретному пользователю
        messagingTemplate.convertAndSendToUser(userName, "/topic/trades", 
                "Config received successfully");
    }
}
```

## Почему ваш код не работал

| Что было | Почему не работало |
|---|---|
| `convertAndSendToUser(sessionId, "/topic/trades", ...)` | Spring ищет `Principal` с именем равным sessionId — не находит |
| Нет `Principal` у соединения | `convertAndSendToUser` требует имя пользователя, а не sessionId |
| Клиент подписан на `/user/topic/trades` | Spring не может сматчить подписку без `Principal` |

## Что касается `@MessageMapping`

Ваш `@MessageMapping("/config")` — **правильный**. Клиент отправляет на `/app/config`, Spring отрезает префикс `/app` и маршрутизирует на метод с `@MessageMapping("/config")`. Добавлять `@MessageMapping("/app")` **не нужно**.
