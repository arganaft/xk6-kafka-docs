## Анализ проблемы

Ошибка `Column 'timestamp' not found in any table` возникает потому, что:

1. **Схема строится из первого JSON** — если в первых записях нет поля `timestamp`, оно не попадает в схему
2. **`putIfAbsent` не обновляет тип** — если поле уже есть с одним типом, новый тип не применяется
3. **Схема пересоздаётся при каждом `updateData`** — если новые данные не содержат поле, оно теряется

## Решение

### 1. Исправленный `JsonTable` с накопительной схемой

```java
package com.websocket.trade.calcite;

import org.apache.calcite.DataContext;
import org.apache.calcite.linq4j.AbstractEnumerable;
import org.apache.calcite.linq4j.Enumerable;
import org.apache.calcite.linq4j.Enumerator;
import org.apache.calcite.rel.type.RelDataType;
import org.apache.calcite.rel.type.RelDataTypeFactory;
import org.apache.calcite.schema.ScannableTable;
import org.apache.calcite.schema.impl.AbstractTable;
import org.apache.calcite.sql.type.SqlTypeName;

import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class JsonTable extends AbstractTable implements ScannableTable {

    private final CopyOnWriteArrayList<Map<String, Object>> data;
    
    // Накопительная схема — колонки только добавляются, не удаляются
    private final LinkedHashMap<String, SqlTypeName> columnTypes;
    private final ReadWriteLock schemaLock = new ReentrantReadWriteLock();

    public JsonTable(List<Map<String, Object>> initialData) {
        this.data = new CopyOnWriteArrayList<>(initialData);
        this.columnTypes = new LinkedHashMap<>();
        mergeSchema(initialData);
    }

    public void updateData(List<Map<String, Object>> newData) {
        this.data.clear();
        this.data.addAll(newData);
        // Схема только расширяется, не сбрасывается
        mergeSchema(newData);
    }

    public void appendData(List<Map<String, Object>> newRows) {
        this.data.addAll(newRows);
        mergeSchema(newRows);
    }

    public void clearData() {
        this.data.clear();
        // Схему НЕ очищаем — структура таблицы сохраняется
    }

    /**
     * Накопительное обновление схемы.
     * Новые колонки добавляются, существующие не перезаписываются.
     * Если тип уточняется (например NULL -> INTEGER), обновляем.
     */
    private void mergeSchema(List<Map<String, Object>> rows) {
        schemaLock.writeLock().lock();
        try {
            for (Map<String, Object> row : rows) {
                for (Map.Entry<String, Object> entry : row.entrySet()) {
                    String key = entry.getKey();
                    SqlTypeName inferredType = inferSqlType(entry.getValue());
                    
                    columnTypes.merge(key, inferredType, (existing, newType) -> {
                        // Если существующий тип VARCHAR (неточный) и новый более специфичный — обновляем
                        if (existing == SqlTypeName.VARCHAR && newType != SqlTypeName.VARCHAR) {
                            return newType;
                        }
                        // Если типы конфликтуют — оставляем VARCHAR как универсальный
                        if (existing != newType && newType != SqlTypeName.VARCHAR) {
                            return resolveTypeConflict(existing, newType);
                        }
                        return existing;
                    });
                }
            }
            
            // Гарантируем наличие хотя бы одной колонки
            if (columnTypes.isEmpty()) {
                columnTypes.put("_empty", SqlTypeName.VARCHAR);
            }
        } finally {
            schemaLock.writeLock().unlock();
        }
    }

    /**
     * Разрешение конфликта типов при несовпадении
     */
    private SqlTypeName resolveTypeConflict(SqlTypeName existing, SqlTypeName newType) {
        // Числовые типы — расширяем до большего
        Set<SqlTypeName> numericTypes = Set.of(
            SqlTypeName.INTEGER, SqlTypeName.BIGINT, 
            SqlTypeName.DOUBLE, SqlTypeName.DECIMAL, SqlTypeName.FLOAT
        );
        
        if (numericTypes.contains(existing) && numericTypes.contains(newType)) {
            // Приоритет: DECIMAL > DOUBLE > BIGINT > INTEGER
            if (existing == SqlTypeName.DECIMAL || newType == SqlTypeName.DECIMAL) {
                return SqlTypeName.DECIMAL;
            }
            if (existing == SqlTypeName.DOUBLE || newType == SqlTypeName.DOUBLE) {
                return SqlTypeName.DOUBLE;
            }
            if (existing == SqlTypeName.BIGINT || newType == SqlTypeName.BIGINT) {
                return SqlTypeName.BIGINT;
            }
        }
        
        // Любой конфликт -> VARCHAR
        return SqlTypeName.VARCHAR;
    }

    private SqlTypeName inferSqlType(Object value) {
        if (value == null)                              return SqlTypeName.VARCHAR;
        if (value instanceof Boolean)                   return SqlTypeName.BOOLEAN;
        if (value instanceof Integer)                   return SqlTypeName.INTEGER;
        if (value instanceof Long)                      return SqlTypeName.BIGINT;
        if (value instanceof Float)                     return SqlTypeName.FLOAT;
        if (value instanceof Double)                    return SqlTypeName.DOUBLE;
        if (value instanceof Number)                    return SqlTypeName.DECIMAL;
        
        // Попытка распознать строки как числа или timestamp
        if (value instanceof String str) {
            return inferStringType(str);
        }
        
        return SqlTypeName.VARCHAR;
    }

    /**
     * Попытка определить тип строкового значения
     */
    private SqlTypeName inferStringType(String str) {
        if (str.isBlank()) return SqlTypeName.VARCHAR;
        
        // Проверка на целое число
        try {
            Long.parseLong(str);
            return SqlTypeName.BIGINT;
        } catch (NumberFormatException ignored) {}
        
        // Проверка на дробное число
        try {
            Double.parseDouble(str);
            return SqlTypeName.DOUBLE;
        } catch (NumberFormatException ignored) {}
        
        // Проверка на boolean
        if ("true".equalsIgnoreCase(str) || "false".equalsIgnoreCase(str)) {
            return SqlTypeName.BOOLEAN;
        }
        
        return SqlTypeName.VARCHAR;
    }

    @Override
    public RelDataType getRowType(RelDataTypeFactory typeFactory) {
        schemaLock.readLock().lock();
        try {
            RelDataTypeFactory.Builder builder = typeFactory.builder();
            
            for (Map.Entry<String, SqlTypeName> entry : columnTypes.entrySet()) {
                SqlTypeName sqlType = entry.getValue();
                
                switch (sqlType) {
                    case VARCHAR -> builder
                        .add(entry.getKey(), typeFactory.createSqlType(SqlTypeName.VARCHAR, 65535))
                        .nullable(true);
                    case DECIMAL -> builder
                        .add(entry.getKey(), typeFactory.createSqlType(SqlTypeName.DECIMAL, 38, 10))
                        .nullable(true);
                    default -> builder
                        .add(entry.getKey(), typeFactory.createSqlType(sqlType))
                        .nullable(true);
                }
            }
            
            return builder.build();
        } finally {
            schemaLock.readLock().unlock();
        }
    }

    @Override
    public Enumerable<Object[]> scan(DataContext root) {
        // Снимаем snapshot схемы и данных атомарно
        final List<String> columnNames;
        schemaLock.readLock().lock();
        try {
            columnNames = new ArrayList<>(columnTypes.keySet());
        } finally {
            schemaLock.readLock().unlock();
        }
        
        final List<Map<String, Object>> snapshot = List.copyOf(data);

        return new AbstractEnumerable<>() {
            @Override
            public Enumerator<Object[]> enumerator() {
                return new JsonEnumerator(snapshot, columnNames);
            }
        };
    }

    /**
     * Возвращает текущую схему для диагностики
     */
    public Map<String, SqlTypeName> getColumnTypes() {
        schemaLock.readLock().lock();
        try {
            return Collections.unmodifiableMap(new LinkedHashMap<>(columnTypes));
        } finally {
            schemaLock.readLock().unlock();
        }
    }

    // -------------------------------------------------------------------------

    private static class JsonEnumerator implements Enumerator<Object[]> {
        private final List<Map<String, Object>> data;
        private final List<String> columns;
        private int index = -1;

        JsonEnumerator(List<Map<String, Object>> data, List<String> columns) {
            this.data = data;
            this.columns = columns;
        }

        @Override
        public Object[] current() {
            Map<String, Object> row = data.get(index);
            Object[] result = new Object[columns.size()];
            
            for (int i = 0; i < columns.size(); i++) {
                result[i] = convertValue(row.get(columns.get(i)));
            }
            return result;
        }

        private Object convertValue(Object val) {
            if (val == null) return null;
            // Числа и boolean передаём как есть
            if (val instanceof Number || val instanceof Boolean) return val;
            // Всё остальное — строка
            return val.toString();
        }

        @Override
        public boolean moveNext() {
            return ++index < data.size();
        }

        @Override
        public void reset() {
            index = -1;
        }

        @Override
        public void close() {}
    }
}
```

### 2. Менеджер схем с предзагрузкой известных полей

Если структура JSON известна заранее — лучше зарегистрировать схему явно:

```java
package com.websocket.trade.calcite;

import org.apache.calcite.sql.type.SqlTypeName;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * Предопределённые схемы для известных типов объектов.
 * Решает проблему отсутствия колонок когда первые данные их не содержат.
 */
public class JsonTableSchemaRegistry {

    /**
     * Схема для trades — все возможные поля
     */
    public static LinkedHashMap<String, SqlTypeName> tradesSchema() {
        LinkedHashMap<String, SqlTypeName> schema = new LinkedHashMap<>();
        
        // Идентификаторы
        schema.put("globalId",      SqlTypeName.VARCHAR);
        schema.put("id",            SqlTypeName.VARCHAR);
        schema.put("tradeId",       SqlTypeName.VARCHAR);
        
        // Статус и метаданные
        schema.put("status",        SqlTypeName.VARCHAR);
        schema.put("revision",      SqlTypeName.BIGINT);
        schema.put("timestamp",     SqlTypeName.BIGINT);   // <-- было потеряно
        schema.put("createdAt",     SqlTypeName.VARCHAR);
        schema.put("updatedAt",     SqlTypeName.VARCHAR);
        schema.put("closedAt",      SqlTypeName.VARCHAR);
        
        // FX поля
        schema.put("fxSubtype",     SqlTypeName.VARCHAR);
        schema.put("symbol",        SqlTypeName.VARCHAR);
        schema.put("baseAmount",    SqlTypeName.DECIMAL);
        schema.put("quoteAmount",   SqlTypeName.DECIMAL);
        schema.put("price",         SqlTypeName.DOUBLE);
        schema.put("volume",        SqlTypeName.DOUBLE);
        schema.put("confirmedBy",   SqlTypeName.INTEGER);
        
        return schema;
    }

    /**
     * Создаёт JsonTable с предзагруженной схемой
     */
    public static JsonTable createTradesTable(List<Map<String, Object>> initialData) {
        return new JsonTable(initialData, tradesSchema());
    }
}
```

### 3. Обновлённый конструктор `JsonTable` с поддержкой предзагруженной схемы

```java
// Добавить в JsonTable

/**
 * Конструктор с предопределённой схемой.
 * Данные могут не содержать все поля — схема уже известна.
 */
public JsonTable(List<Map<String, Object>> initialData, 
                 LinkedHashMap<String, SqlTypeName> predefinedSchema) {
    this.data = new CopyOnWriteArrayList<>(initialData);
    this.columnTypes = new LinkedHashMap<>(predefinedSchema);
    // Дополняем схему из данных (новые неизвестные поля)
    mergeSchema(initialData);
}
```

## Итог — причины ошибки и что исправлено

| Проблема | Было | Стало |
|----------|------|-------|
| Поле `timestamp` отсутствует в первых записях | Схема строилась только из первого батча | Схема накапливается из всех батчей |
| `updateData` сбрасывал схему | `columnTypes = inferSchema(newData)` | `mergeSchema()` только добавляет колонки |
| Конфликт типов → потеря поля | Не обрабатывался | `resolveTypeConflict()` |
| Нет гарантии наличия известных полей | — | `JsonTableSchemaRegistry` с предзагрузкой |
