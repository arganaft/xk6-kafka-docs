Внедрение OpenTelemetry (OTel) в Spring Boot можно выполнить двумя основными способами: **автоматическим** (через Java Agent) и **программным** (через Starter).

Для Spring Boot приложений сейчас наиболее актуален и удобен вариант с использованием официального **OpenTelemetry Spring Boot Starter**. Он интегрируется с контекстом Spring и позволяет гибко настраивать экспорт данных.

---

## 1. Зависимости в `pom.xml`

Чтобы всё работало корректно и версии не конфликтовали, лучше всего использовать **BOM (Bill of Materials)**.

```xml
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>io.opentelemetry</groupId>
            <artifactId>opentelemetry-bom</artifactId>
            <version>1.38.0</version> <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

<dependencies>
    <dependency>
        <groupId>io.opentelemetry.instrumentation</groupId>
        <artifactId>opentelemetry-spring-boot-starter</artifactId>
        <version>2.4.0-alpha</version> </dependency>

    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-exporter-otlp</artifactId>
    </dependency>

    <dependency>
        <groupId>io.opentelemetry.instrumentation</groupId>
        <artifactId>opentelemetry-logback-appender-1.0</artifactId>
        <version>2.4.0-alpha</version>
        <scope>runtime</scope>
    </dependency>
</dependencies>

```

---

## 2. Архитектура потока данных

Перед настройкой важно понимать, как данные покидают ваше приложение.

---

## 3. Настройка `application.yaml` (или `.properties`)

После добавления зависимостей OpenTelemetry начнет собирать базовые метрики и трейсы, но их нужно куда-то отправить. Чаще всего используется протокол **OTLP**.

```yaml
otel:
  service:
    name: my-spring-boot-service # Имя вашего микросервиса
  exporter:
    otlp:
      endpoint: http://localhost:4318 # Адрес OTel Collector или Jaeger
  traces:
    exporter: otlp
  metrics:
    exporter: otlp
  logs:
    exporter: otlp
  instrumentation:
    # Можно выборочно включать/выключать модули
    spring-web:
      enabled: true
    jdbc:
      enabled: true

```

---

## 4. Как это работает (Краткий чек-лист)

1. **Трейсинг:** Автоматически создает Span'ы для всех входящих HTTP-запросов (через RestTemplate или WebClient) и запросов к БД.
2. **Метрики:** Собирает стандартные метрики JVM (память, потоки) и Spring (запросы, ошибки).
3. **Логи:** Если вы добавили Logback Appender, OpenTelemetry будет добавлять `trace_id` и `span_id` в каждый лог, что критически важно для отладки.

---

## Альтернатива: Java Agent

Если вы не хотите менять код и `pom.xml`, можно использовать **Java Agent**. Это "черный ящик", который подключается при запуске JAR-файла:

1. Скачиваете `opentelemetry-javaagent.jar`.
2. Запускаете приложение:
`java -javaagent:path/to/opentelemetry-javaagent.jar -Dotel.service.name=my-app -jar app.jar`

**Когда что выбирать?**

* **Starter (через POM):** Если вам нужна глубокая интеграция с кодом, кастомные бины `OpenTelemetry` или если вы деплоитесь в среду, где сложно менять параметры запуска.
* **Agent:** Если нужно быстро внедрить мониторинг в кучу разных сервисов без пересборки кода.

Хотите, я помогу составить конфигурацию для конкретного бэкенда, например, для **Jaeger** или **Prometheus**?










Судя по логам и выводу Actuator, **OpenTelemetry в вашем приложении сейчас не работает**.

Я заметил две критические причины, почему это происходит:

1. **Приложение не видит ваш ConfigMap**: В логе запуска имя приложения `IDGenerationApplication`, а в ConfigMap указано `object-repository-id-generation-service-k8s`. Если бы Spring прочитал конфиг, в логе было бы длинное имя.
2. **Отсутствие автоконфигурации**: В `actuator/beans` пусто, значит, Spring Boot не создал бины OpenTelemetry.

Давайте пошагово это исправим.

---

### Шаг 1: Исправляем загрузку конфигурации

Ваш ConfigMap содержит данные в блоке `properties: |`. Чтобы Spring Boot их увидел, нужно либо чтобы этот файл назывался `application.properties` и лежал в рабочей директории, либо его нужно импортировать.

Добавьте в параметры запуска (в Deployment Kubernetes) или в файл, который точно читается, путь к конфигу:

```yaml
# В блоке env вашего контейнера в K8s
- name: SPRING_CONFIG_IMPORT
  value: "optional:file:/deployments/config/application.properties" 

```

*(Проверьте, по какому пути в контейнере монтируется ваш ConfigMap)*.

---

### Шаг 2: Правильные зависимости (Spring Boot 3 + Java 21)

Для Spring Boot 3 лучше использовать **Micrometer Tracing** с мостом в OpenTelemetry. Это нативный путь для новых версий Spring. Удалите старые зависимости OTel и добавьте эти:

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>

    <dependency>
        <groupId>io.micrometer</groupId>
        <artifactId>micrometer-tracing-bridge-otel</artifactId>
    </dependency>

    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-exporter-otlp</artifactId>
    </dependency>
</dependencies>

```

---

### Шаг 3: Настройка в ConfigMap

Для Spring Boot 3 названия свойств немного отличаются от тех, что были в моем первом ответе (Spring Boot 3 использует префикс `management.otlp`).

Обновите ваш блок `properties` в ConfigMap:

```yaml
    # Имя сервиса для OTel
    otel.service.name: object-repository-id-generation-service-k8s

    # Настройка трейсинга (Spring Boot 3)
    management:
      otlp:
        tracing:
          endpoint: http://your-otel-collector:4318/v1/traces
      tracing:
        sampling:
          probability: 1.0 # Собирать 100% трейсов (для теста)
      
      # Если хотите, чтобы метрики тоже уходили по OTLP
      metrics:
        export:
          otlp:
            enabled: true
            step: 10s
            url: http://your-otel-collector:4318/v1/metrics

      endpoints:
        web:
          exposure:
            # Добавьте otlp в список, если нужно проверять статус
            include: health,info,metrics,prometheus,otel 

```

---

### Как проверить, что заработало?

1. **Логи запуска:** Теперь в логах при старте должна появиться фраза:
`INFO ... [main] o.s.b.a.e.web.EndpointLinksResolver : Exposing 5 endpoints beneath base path '/actuator'` (было 4, добавится один для OTel/Tracing).
2. **Actuator Beans:**
```bash
curl -s http://localhost:8080/actuator/beans | grep -i tracing

```


Вы должны увидеть бины `OtlpHttpTracingAutoConfiguration` или `OtlpTracingEndpoint`.
3. **HTTP Запрос:** Сделайте запрос к вашему контроллеру (`/getId`), а затем проверьте заголовки ответа. Если трейсинг работает, в логах самого приложения (если настроен формат) появится `trace_id`.

### Почему `jcmd` выдал ошибку?

`java.io.IOException: Read-only file system` — это норма для Kubernetes, если контейнер запущен с флагом `readOnlyRootFilesystem: true`. В этом случае `jcmd` не может создать временный файл для связи с процессом. Не мучайте его, **Actuator — ваш главный инструмент диагностики здесь.**

**Хотите, я помогу прописать правильный `mountPath` в вашем Deployment, чтобы конфиги точно подцепились?**










Судя по логам и выводу Actuator, **OpenTelemetry в вашем приложении сейчас не работает**.

Я заметил две критические причины, почему это происходит:

1. **Приложение не видит ваш ConfigMap**: В логе запуска имя приложения `IDGenerationApplication`, а в ConfigMap указано `object-repository-id-generation-service-k8s`. Если бы Spring прочитал конфиг, в логе было бы длинное имя.
2. **Отсутствие автоконфигурации**: В `actuator/beans` пусто, значит, Spring Boot не создал бины OpenTelemetry.

Давайте пошагово это исправим.

---

### Шаг 1: Исправляем загрузку конфигурации

Ваш ConfigMap содержит данные в блоке `properties: |`. Чтобы Spring Boot их увидел, нужно либо чтобы этот файл назывался `application.properties` и лежал в рабочей директории, либо его нужно импортировать.

Добавьте в параметры запуска (в Deployment Kubernetes) или в файл, который точно читается, путь к конфигу:

```yaml
# В блоке env вашего контейнера в K8s
- name: SPRING_CONFIG_IMPORT
  value: "optional:file:/deployments/config/application.properties" 

```

*(Проверьте, по какому пути в контейнере монтируется ваш ConfigMap)*.

---

### Шаг 2: Правильные зависимости (Spring Boot 3 + Java 21)

Для Spring Boot 3 лучше использовать **Micrometer Tracing** с мостом в OpenTelemetry. Это нативный путь для новых версий Spring. Удалите старые зависимости OTel и добавьте эти:

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>

    <dependency>
        <groupId>io.micrometer</groupId>
        <artifactId>micrometer-tracing-bridge-otel</artifactId>
    </dependency>

    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-exporter-otlp</artifactId>
    </dependency>
</dependencies>

```

---

### Шаг 3: Настройка в ConfigMap

Для Spring Boot 3 названия свойств немного отличаются от тех, что были в моем первом ответе (Spring Boot 3 использует префикс `management.otlp`).

Обновите ваш блок `properties` в ConfigMap:

```yaml
    # Имя сервиса для OTel
    otel.service.name: object-repository-id-generation-service-k8s

    # Настройка трейсинга (Spring Boot 3)
    management:
      otlp:
        tracing:
          endpoint: http://your-otel-collector:4318/v1/traces
      tracing:
        sampling:
          probability: 1.0 # Собирать 100% трейсов (для теста)
      
      # Если хотите, чтобы метрики тоже уходили по OTLP
      metrics:
        export:
          otlp:
            enabled: true
            step: 10s
            url: http://your-otel-collector:4318/v1/metrics

      endpoints:
        web:
          exposure:
            # Добавьте otlp в список, если нужно проверять статус
            include: health,info,metrics,prometheus,otel 

```

---

### Как проверить, что заработало?

1. **Логи запуска:** Теперь в логах при старте должна появиться фраза:
`INFO ... [main] o.s.b.a.e.web.EndpointLinksResolver : Exposing 5 endpoints beneath base path '/actuator'` (было 4, добавится один для OTel/Tracing).
2. **Actuator Beans:**
```bash
curl -s http://localhost:8080/actuator/beans | grep -i tracing

```


Вы должны увидеть бины `OtlpHttpTracingAutoConfiguration` или `OtlpTracingEndpoint`.
3. **HTTP Запрос:** Сделайте запрос к вашему контроллеру (`/getId`), а затем проверьте заголовки ответа. Если трейсинг работает, в логах самого приложения (если настроен формат) появится `trace_id`.

### Почему `jcmd` выдал ошибку?

`java.io.IOException: Read-only file system` — это норма для Kubernetes, если контейнер запущен с флагом `readOnlyRootFilesystem: true`. В этом случае `jcmd` не может создать временный файл для связи с процессом. Не мучайте его, **Actuator — ваш главный инструмент диагностики здесь.**

**Хотите, я помогу прописать правильный `mountPath` в вашем Deployment, чтобы конфиги точно подцепились?**
