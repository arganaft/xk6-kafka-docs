

# Архитектура обработки клиентских запросов и генерации SQL

## 1. Да, стоит заменить `@Payload String` на типизированный объект

Это даст валидацию, type-safety и чистую маршрутизацию.

## 2. Модели данных

### Базовая обёртка входящего сообщения

```java
package com.trade.ws.model.request;

import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;

@JsonTypeInfo(
    use = JsonTypeInfo.Id.NAME,
    include = JsonTypeInfo.As.EXISTING_PROPERTY,
    property = "type",
    visible = true
)
@JsonSubTypes({
    @JsonSubTypes.Type(value = SetViewConfigurationRequest.class, name = "SetViewConfiguration"),
    @JsonSubTypes.Type(value = RequestImmediateDataRequest.class, name = "RequestImmediateData"),
    @JsonSubTypes.Type(value = GetCurrentConfigRequest.class, name = "GetCurrentConfig")
})
public abstract class ClientRequest {
    
    private String type;

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }
}
```

### SetViewConfigurationRequest

```java
package com.trade.ws.model.request;

import com.trade.ws.model.config.StreamViewConfig;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotNull;

public class SetViewConfigurationRequest extends ClientRequest {

    @NotNull
    @Valid
    private StreamViewConfig data;

    public StreamViewConfig getData() {
        return data;
    }

    public void setData(StreamViewConfig data) {
        this.data = data;
    }
}
```

### RequestImmediateDataRequest

```java
package com.trade.ws.model.request;

import com.trade.ws.model.config.StreamViewConfig;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotNull;

public class RequestImmediateDataRequest extends ClientRequest {

    @NotNull
    @Valid
    private StreamViewConfig data;

    public StreamViewConfig getData() {
        return data;
    }

    public void setData(StreamViewConfig data) {
        this.data = data;
    }
}
```

### GetCurrentConfigRequest

```java
package com.trade.ws.model.request;

import jakarta.validation.constraints.NotBlank;

public class GetCurrentConfigRequest extends ClientRequest {

    @NotBlank
    private String requestId;

    public String getRequestId() {
        return requestId;
    }

    public void setRequestId(String requestId) {
        this.requestId = requestId;
    }
}
```

## 3. Модели конфигурации

### GridColumn

```java
package com.trade.ws.model.config;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

public class GridColumn {

    @NotNull
    private Integer id;

    @NotBlank
    private String fieldKey;

    @NotBlank
    private String name;

    @NotBlank
    private String dataType; // string, number, date, boolean

    // getters & setters

    public Integer getId() { return id; }
    public void setId(Integer id) { this.id = id; }

    public String getFieldKey() { return fieldKey; }
    public void setFieldKey(String fieldKey) { this.fieldKey = fieldKey; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getDataType() { return dataType; }
    public void setDataType(String dataType) { this.dataType = dataType; }
}
```

### GridAggColumn

```java
package com.trade.ws.model.config;

public class GridAggColumn extends GridColumn {

    private String aggFunc; // sum, avg, min, max, count

    public String getAggFunc() { return aggFunc; }
    public void setAggFunc(String aggFunc) { this.aggFunc = aggFunc; }
}
```

### SortModel

```java
package com.trade.ws.model.config;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;

public class SortModel {

    @NotBlank
    private String colId;

    @NotBlank
    @Pattern(regexp = "asc|desc")
    private String sort;

    public String getColId() { return colId; }
    public void setColId(String colId) { this.colId = colId; }

    public String getSort() { return sort; }
    public void setSort(String sort) { this.sort = sort; }
}
```

### StreamViewConfig

```java
package com.trade.ws.model.config;

import jakarta.validation.Valid;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import java.util.List;
import java.util.Map;

public class StreamViewConfig {

    @NotNull
    @Min(0)
    private Integer startRow;

    @NotNull
    @Min(1)
    private Integer endRow;

    @NotNull
    private String requestId;

    private String clientId;

    @NotNull
    @Valid
    private List<GridColumn> columns;

    @NotNull
    @Valid
    private List<GridColumn> rowGroupColumns;

    @NotNull
    @Valid
    private List<GridAggColumn> valueColumns;

    @NotNull
    @Valid
    private List<GridColumn> pivotColumns;

    @NotNull
    private Boolean pivotMode;

    @NotNull
    private Map<String, Object> filterModel;

    @NotNull
    @Valid
    private List<SortModel> sortModel;

    @NotNull
    private List<String> groupKeys;

    // --- Transient, не от клиента ---
    private transient String sessionId;

    // getters & setters

    public Integer getStartRow() { return startRow; }
    public void setStartRow(Integer startRow) { this.startRow = startRow; }

    public Integer getEndRow() { return endRow; }
    public void setEndRow(Integer endRow) { this.endRow = endRow; }

    public String getRequestId() { return requestId; }
    public void setRequestId(String requestId) { this.requestId = requestId; }

    public String getClientId() { return clientId; }
    public void setClientId(String clientId) { this.clientId = clientId; }

    public List<GridColumn> getColumns() { return columns; }
    public void setColumns(List<GridColumn> columns) { this.columns = columns; }

    public List<GridColumn> getRowGroupColumns() { return rowGroupColumns; }
    public void setRowGroupColumns(List<GridColumn> rowGroupColumns) { this.rowGroupColumns = rowGroupColumns; }

    public List<GridAggColumn> getValueColumns() { return valueColumns; }
    public void setValueColumns(List<GridAggColumn> valueColumns) { this.valueColumns = valueColumns; }

    public List<GridColumn> getPivotColumns() { return pivotColumns; }
    public void setPivotColumns(List<GridColumn> pivotColumns) { this.pivotColumns = pivotColumns; }

    public Boolean getPivotMode() { return pivotMode; }
    public void setPivotMode(Boolean pivotMode) { this.pivotMode = pivotMode; }

    public Map<String, Object> getFilterModel() { return filterModel; }
    public void setFilterModel(Map<String, Object> filterModel) { this.filterModel = filterModel; }

    public List<SortModel> getSortModel() { return sortModel; }
    public void setSortModel(List<SortModel> sortModel) { this.sortModel = sortModel; }

    public List<String> getGroupKeys() { return groupKeys; }
    public void setGroupKeys(List<String> groupKeys) { this.groupKeys = groupKeys; }

    public String getSessionId() { return sessionId; }
    public void setSessionId(String sessionId) { this.sessionId = sessionId; }
}
```

## 4. Главный класс — SQL Builder

Это ключевой класс, который из `StreamViewConfig` строит параметризованный SQL-запрос.

### SqlQueryResult — результат построения

```java
package com.trade.ws.sql;

import java.util.List;

/**
 * Результат построения SQL: запрос + параметры для PreparedStatement
 */
public record SqlQueryResult(
    String sql,
    List<Object> params
) {}
```

### SqlQueryBuilder

```java
package com.trade.ws.sql;

import com.trade.ws.model.config.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Строит SQL-запрос на основе StreamViewConfig.
 *
 * Поддерживает:
 * - SELECT колонок / агрегатов
 * - WHERE по filterModel
 * - GROUP BY по rowGroupColumns + groupKeys (иерархическая группировка)
 * - ORDER BY по sortModel
 * - LIMIT/OFFSET по startRow/endRow
 *
 * Все пользовательские значения передаются через параметры (защита от SQL injection).
 * Имена колонок валидируются через whitelist.
 */
public class SqlQueryBuilder {

    private static final Logger log = LoggerFactory.getLogger(SqlQueryBuilder.class);

    /**
     * Имя исходной таблицы (или view) в БД.
     * В реальном проекте может приходить из конфигурации.
     */
    private final String tableName;

    /**
     * Белый список допустимых имён колонок.
     * Защита от SQL injection через имена полей.
     */
    private final Set<String> allowedColumns;

    public SqlQueryBuilder(String tableName, Set<String> allowedColumns) {
        this.tableName = tableName;
        this.allowedColumns = allowedColumns;
    }

    /**
     * Основной метод: StreamViewConfig → SQL + params
     */
    public SqlQueryResult build(StreamViewConfig config) {
        List<Object> params = new ArrayList<>();
        StringBuilder sql = new StringBuilder();

        // ===== SELECT =====
        sql.append("SELECT ");
        sql.append(buildSelectClause(config));

        // ===== FROM =====
        sql.append(" FROM ").append(sanitizeIdentifier(tableName));

        // ===== WHERE =====
        String whereClause = buildWhereClause(config, params);
        if (!whereClause.isEmpty()) {
            sql.append(" WHERE ").append(whereClause);
        }

        // ===== GROUP BY =====
        String groupByClause = buildGroupByClause(config);
        if (!groupByClause.isEmpty()) {
            sql.append(" GROUP BY ").append(groupByClause);
        }

        // ===== ORDER BY =====
        String orderByClause = buildOrderByClause(config);
        if (!orderByClause.isEmpty()) {
            sql.append(" ORDER BY ").append(orderByClause);
        }

        // ===== LIMIT / OFFSET =====
        sql.append(" LIMIT ?");
        params.add(config.getEndRow() - config.getStartRow());

        sql.append(" OFFSET ?");
        params.add(config.getStartRow());

        String finalSql = sql.toString();
        log.debug("Built SQL: {} with params: {}", finalSql, params);

        return new SqlQueryResult(finalSql, params);
    }

    // ==================== SELECT ====================

    private String buildSelectClause(StreamViewConfig config) {
        boolean hasGrouping = !config.getRowGroupColumns().isEmpty();
        boolean isFullyExpanded = hasGrouping
            && config.getGroupKeys().size() >= config.getRowGroupColumns().size();

        // Случай 1: Нет группировки или все группы раскрыты — показываем все колонки
        if (!hasGrouping || isFullyExpanded) {
            if (config.getColumns().isEmpty()) {
                return "*";
            }
            return config.getColumns().stream()
                .map(col -> sanitizeColumnName(col.getFieldKey()))
                .collect(Collectors.joining(", "));
        }

        // Случай 2: Есть группировка, показываем текущий уровень группы + агрегаты
        List<String> selectParts = new ArrayList<>();

        // Текущая колонка группировки (следующий уровень после раскрытых)
        int currentLevel = config.getGroupKeys().size();
        GridColumn groupCol = config.getRowGroupColumns().get(currentLevel);
        selectParts.add(sanitizeColumnName(groupCol.getFieldKey()));

        // Агрегатные колонки
        for (GridAggColumn aggCol : config.getValueColumns()) {
            String aggFunc = validateAggFunc(aggCol.getAggFunc());
            String field = sanitizeColumnName(aggCol.getFieldKey());
            selectParts.add(aggFunc + "(" + field + ") AS " + field);
        }

        // COUNT(*) для информации о количестве записей в группе
        selectParts.add("COUNT(*) AS _group_count");

        return String.join(", ", selectParts);
    }

    // ==================== WHERE ====================

    /**
     * Строит WHERE из filterModel + groupKeys.
     *
     * filterModel поддерживает форматы:
     *
     * 1. Простой фильтр:
     *    {"price": {"filterType": "number", "type": "greaterThan", "filter": 100}}
     *
     * 2. Комбинированный фильтр:
     *    {"price": {"filterType": "number", "operator": "AND",
     *               "condition1": {"type": "greaterThan", "filter": 100},
     *               "condition2": {"type": "lessThan", "filter": 500}}}
     *
     * 3. Set фильтр:
     *    {"symbol": {"filterType": "set", "values": ["AAPL", "MSFT"]}}
     */
    private String buildWhereClause(StreamViewConfig config, List<Object> params) {
        List<String> conditions = new ArrayList<>();

        // 1. Фильтры из groupKeys (иерархическая навигация)
        //    Если groupKeys = ["Technology", "Hardware"], а rowGroupColumns = [sector, category, ...]
        //    то добавляем: sector = 'Technology' AND category = 'Hardware'
        if (!config.getGroupKeys().isEmpty() && !config.getRowGroupColumns().isEmpty()) {
            for (int i = 0; i < config.getGroupKeys().size(); i++) {
                if (i < config.getRowGroupColumns().size()) {
                    String colName = sanitizeColumnName(
                        config.getRowGroupColumns().get(i).getFieldKey()
                    );
                    conditions.add(colName + " = ?");
                    params.add(config.getGroupKeys().get(i));
                }
            }
        }

        // 2. Фильтры из filterModel
        if (config.getFilterModel() != null && !config.getFilterModel().isEmpty()) {
            for (Map.Entry<String, Object> entry : config.getFilterModel().entrySet()) {
                String columnName = sanitizeColumnName(entry.getKey());

                if (entry.getValue() instanceof Map<?, ?> filterDef) {
                    @SuppressWarnings("unchecked")
                    Map<String, Object> filter = (Map<String, Object>) filterDef;
                    String filterCondition = buildFilterCondition(columnName, filter, params);
                    if (filterCondition != null && !filterCondition.isEmpty()) {
                        conditions.add(filterCondition);
                    }
                }
            }
        }

        return String.join(" AND ", conditions);
    }

    /**
     * Обрабатывает один фильтр (простой или комбинированный)
     */
    private String buildFilterCondition(
            String columnName,
            Map<String, Object> filter,
            List<Object> params
    ) {
        // Комбинированный фильтр (operator + condition1 + condition2)
        if (filter.containsKey("operator")) {
            String operator = ((String) filter.get("operator")).toUpperCase();
            if (!operator.equals("AND") && !operator.equals("OR")) {
                log.warn("Invalid operator: {}", operator);
                return null;
            }

            @SuppressWarnings("unchecked")
            Map<String, Object> cond1 = (Map<String, Object>) filter.get("condition1");
            @SuppressWarnings("unchecked")
            Map<String, Object> cond2 = (Map<String, Object>) filter.get("condition2");

            String sql1 = buildSingleFilterCondition(columnName, cond1, params);
            String sql2 = buildSingleFilterCondition(columnName, cond2, params);

            if (sql1 != null && sql2 != null) {
                return "(" + sql1 + " " + operator + " " + sql2 + ")";
            }
            return sql1 != null ? sql1 : sql2;
        }

        // Set фильтр
        String filterType = (String) filter.get("filterType");
        if ("set".equals(filterType)) {
            return buildSetFilter(columnName, filter, params);
        }

        // Простой фильтр
        return buildSingleFilterCondition(columnName, filter, params);
    }

    /**
     * Простой фильтр: type + filter [+ filterTo]
     */
    private String buildSingleFilterCondition(
            String columnName,
            Map<String, Object> filter,
            List<Object> params
    ) {
        String type = (String) filter.get("type");
        Object filterValue = filter.get("filter");
        Object filterTo = filter.get("filterTo");

        if (type == null) {
            return null;
        }

        return switch (type) {
            case "equals" -> {
                params.add(filterValue);
                yield columnName + " = ?";
            }
            case "notEqual" -> {
                params.add(filterValue);
                yield columnName + " != ?";
            }
            case "contains" -> {
                params.add("%" + filterValue + "%");
                yield columnName + " ILIKE ?";
            }
            case "notContains" -> {
                params.add("%" + filterValue + "%");
                yield columnName + " NOT ILIKE ?";
            }
            case "startsWith" -> {
                params.add(filterValue + "%");
                yield columnName + " ILIKE ?";
            }
            case "endsWith" -> {
                params.add("%" + filterValue);
                yield columnName + " ILIKE ?";
            }
            case "greaterThan" -> {
                params.add(filterValue);
                yield columnName + " > ?";
            }
            case "greaterThanOrEqual" -> {
                params.add(filterValue);
                yield columnName + " >= ?";
            }
            case "lessThan" -> {
                params.add(filterValue);
                yield columnName + " < ?";
            }
            case "lessThanOrEqual" -> {
                params.add(filterValue);
                yield columnName + " <= ?";
            }
            case "inRange" -> {
                if (filterTo != null) {
                    params.add(filterValue);
                    params.add(filterTo);
                    yield columnName + " BETWEEN ? AND ?";
                }
                yield null;
            }
            case "blank" -> columnName + " IS NULL";
            case "notBlank" -> columnName + " IS NOT NULL";
            default -> {
                log.warn("Unknown filter type: {}", type);
                yield null;
            }
        };
    }

    /**
     * Set фильтр: values = [...]
     */
    private String buildSetFilter(
            String columnName,
            Map<String, Object> filter,
            List<Object> params
    ) {
        @SuppressWarnings("unchecked")
        List<Object> values = (List<Object>) filter.get("values");
        if (values == null || values.isEmpty()) {
            // Пустой set = ничего не выбрано = невозможное условие
            return "1 = 0";
        }

        String placeholders = values.stream()
            .map(v -> "?")
            .collect(Collectors.joining(", "));
        params.addAll(values);

        return columnName + " IN (" + placeholders + ")";
    }

    // ==================== GROUP BY ====================

    private String buildGroupByClause(StreamViewConfig config) {
        if (config.getRowGroupColumns().isEmpty()) {
            return "";
        }

        // Если все группы раскрыты — не группируем
        if (config.getGroupKeys().size() >= config.getRowGroupColumns().size()) {
            return "";
        }

        // Группируем по текущему уровню
        int currentLevel = config.getGroupKeys().size();
        GridColumn groupCol = config.getRowGroupColumns().get(currentLevel);
        return sanitizeColumnName(groupCol.getFieldKey());
    }

    // ==================== ORDER BY ====================

    private String buildOrderByClause(StreamViewConfig config) {
        if (config.getSortModel() == null || config.getSortModel().isEmpty()) {
            return "";
        }

        return config.getSortModel().stream()
            .map(sort -> {
                String col = sanitizeColumnName(sort.getColId());
                String dir = "desc".equalsIgnoreCase(sort.getSort()) ? "DESC" : "ASC";
                return col + " " + dir;
            })
            .collect(Collectors.joining(", "));
    }

    // ==================== Безопасность ====================

    /**
     * Валидация имени колонки через whitelist.
     * Если колонка не в whitelist — выбрасывает исключение.
     */
    private String sanitizeColumnName(String fieldKey) {
        if (fieldKey == null || fieldKey.isBlank()) {
            throw new IllegalArgumentException("Column name cannot be blank");
        }

        // Проверяем формат: только буквы, цифры, подчёркивания
        if (!fieldKey.matches("^[a-zA-Z_][a-zA-Z0-9_]*$")) {
            throw new IllegalArgumentException("Invalid column name format: " + fieldKey);
        }

        if (!allowedColumns.contains(fieldKey)) {
            throw new IllegalArgumentException("Column not allowed: " + fieldKey);
        }

        return "\"" + fieldKey + "\"";
    }

    /**
     * Валидация имени таблицы
     */
    private String sanitizeIdentifier(String identifier) {
        if (!identifier.matches("^[a-zA-Z_][a-zA-Z0-9_.]*$")) {
            throw new IllegalArgumentException("Invalid identifier: " + identifier);
        }
        return "\"" + identifier + "\"";
    }

    /**
     * Валидация функции агрегации
     */
    private String validateAggFunc(String aggFunc) {
        if (aggFunc == null) {
            return "COUNT";
        }
        return switch (aggFunc.toLowerCase()) {
            case "sum" -> "SUM";
            case "avg" -> "AVG";
            case "min" -> "MIN";
            case "max" -> "MAX";
            case "count" -> "COUNT";
            default -> throw new IllegalArgumentException("Invalid aggregate function: " + aggFunc);
        };
    }
}
```

## 5. Сервис-обёртка

```java
package com.trade.ws.service;

import com.trade.ws.model.config.GridColumn;
import com.trade.ws.model.config.StreamViewConfig;
import com.trade.ws.sql.SqlQueryBuilder;
import com.trade.ws.sql.SqlQueryResult;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

import java.util.*;

@Service
public class QueryService {

    private static final Logger log = LoggerFactory.getLogger(QueryService.class);

    private final JdbcTemplate jdbcTemplate;

    @Value("${app.data.table-name:trades}")
    private String tableName;

    /**
     * В реальном приложении загружается из метаданных БД или конфигурации.
     */
    private Set<String> allowedColumns;

    public QueryService(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @PostConstruct
    public void init() {
        // Загружаем список допустимых колонок из БД
        // В production: SELECT column_name FROM information_schema.columns WHERE table_name = ?
        this.allowedColumns = loadAllowedColumns();
        log.info("Loaded allowed columns for table '{}': {}", tableName, allowedColumns);
    }

    /**
     * Выполняет запрос по конфигурации и возвращает результат
     */
    public QueryResult executeQuery(StreamViewConfig config) {
        SqlQueryBuilder builder = new SqlQueryBuilder(tableName, allowedColumns);
        SqlQueryResult queryResult = builder.build(config);

        log.info("Executing SQL: {} with params: {}", queryResult.sql(), queryResult.params());

        // Получаем данные
        List<Map<String, Object>> rows = jdbcTemplate.queryForList(
            queryResult.sql(),
            queryResult.params().toArray()
        );

        // Получаем общее количество строк (для lastRow)
        int totalRows = getTotalRowCount(config, builder);

        return new QueryResult(rows, totalRows);
    }

    /**
     * COUNT-запрос для определения lastRow
     */
    private int getTotalRowCount(StreamViewConfig config, SqlQueryBuilder builder) {
        // Строим тот же запрос, но без LIMIT/OFFSET, обёрнутый в COUNT
        StreamViewConfig countConfig = new StreamViewConfig();
        countConfig.setStartRow(0);
        countConfig.setEndRow(Integer.MAX_VALUE);
        countConfig.setColumns(config.getColumns());
        countConfig.setRowGroupColumns(config.getRowGroupColumns());
        countConfig.setValueColumns(config.getValueColumns());
        countConfig.setPivotColumns(config.getPivotColumns());
        countConfig.setPivotMode(config.getPivotMode());
        countConfig.setFilterModel(config.getFilterModel());
        countConfig.setSortModel(List.of()); // сортировка не нужна для COUNT
        countConfig.setGroupKeys(config.getGroupKeys());
        countConfig.setRequestId(config.getRequestId());

        SqlQueryResult innerQuery = builder.build(countConfig);

        String countSql = "SELECT COUNT(*) FROM (" + innerQuery.sql() + ") AS _count_query";

        Integer count = jdbcTemplate.queryForObject(
            countSql,
            Integer.class,
            innerQuery.params().toArray()
        );

        return count != null ? count : 0;
    }

    private Set<String> loadAllowedColumns() {
        try {
            List<String> columns = jdbcTemplate.queryForList(
                "SELECT column_name FROM information_schema.columns WHERE table_name = ?",
                String.class,
                tableName
            );
            return new HashSet<>(columns);
        } catch (Exception e) {
            log.warn("Failed to load columns from DB, using defaults", e);
            return Set.of("symbol", "price", "volume", "timestamp", "side", "exchange");
        }
    }

    public record QueryResult(
        List<Map<String, Object>> rows,
        int totalRows
    ) {}
}
```

## 6. Обновлённый контроллер

```java
package com.trade.ws.controller;

import com.trade.ws.model.request.*;
import com.trade.ws.service.TradeStreamService;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.messaging.simp.SimpMessageHeaderAccessor;
import org.springframework.stereotype.Controller;

@Controller
public class TradeController {

    private static final Logger log = LoggerFactory.getLogger(TradeController.class);

    private final TradeStreamService tradeStreamService;

    public TradeController(TradeStreamService tradeStreamService) {
        this.tradeStreamService = tradeStreamService;
    }

    @MessageMapping("/trades")
    public void handleClientRequest(
            @Payload @Valid ClientRequest request,
            SimpMessageHeaderAccessor headerAccessor
    ) {
        String sessionId = headerAccessor.getSessionId();
        String clientId = (String) headerAccessor.getSessionAttributes().get("clientId");

        log.info("Received [{}] from session={}, client={}",
                request.getType(), sessionId, clientId);

        switch (request) {
            case SetViewConfigurationRequest setConfig -> {
                setConfig.getData().setSessionId(sessionId);
                tradeStreamService.handleSetViewConfiguration(sessionId, setConfig.getData());
            }
            case RequestImmediateDataRequest immediateReq -> {
                immediateReq.getData().setSessionId(sessionId);
                tradeStreamService.handleRequestImmediateData(sessionId, immediateReq.getData());
            }
            case GetCurrentConfigRequest getConfig -> {
                tradeStreamService.handleGetCurrentConfig(sessionId, getConfig.getRequestId());
            }
            default -> log.warn("Unknown request type: {}", request.getType());
        }
    }
}
```

## 7. Сервис стриминга

```java
package com.trade.ws.service;

import com.trade.ws.model.config.StreamViewConfig;
import com.trade.ws.service.QueryService.QueryResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class TradeStreamService {

    private static final Logger log = LoggerFactory.getLogger(TradeStreamService.class);

    private final QueryService queryService;
    private final SimpMessagingTemplate messagingTemplate;

    /**
     * Хранилище активных конфигураций: sessionId → config
     * Один клиент может иметь несколько конфигураций (по requestId)
     */
    private final Map<String, Map<String, StreamViewConfig>> activeConfigs = new ConcurrentHashMap<>();

    public TradeStreamService(QueryService queryService, SimpMessagingTemplate messagingTemplate) {
        this.queryService = queryService;
        this.messagingTemplate = messagingTemplate;
    }

    public void handleSetViewConfiguration(String sessionId, StreamViewConfig config) {
        // Сохраняем конфигурацию
        activeConfigs
            .computeIfAbsent(sessionId, k -> new ConcurrentHashMap<>())
            .put(config.getRequestId(), config);

        // Отправляем ConfigurationUpdated
        messagingTemplate.convertAndSendToUser(
            sessionId,
            "/topic/trades",
            Map.of(
                "type", "ConfigurationUpdated",
                "config", config,
                "timestamp", Instant.now().toString()
            )
        );

        // Отправляем первую порцию данных как ReceiveImmediateData
        sendData(sessionId, config, "ReceiveImmediateData");

        log.info("Configuration set for session={}, requestId={}", sessionId, config.getRequestId());
    }

    public void handleRequestImmediateData(String sessionId, StreamViewConfig config) {
        sendData(sessionId, config, "ReceiveImmediateData");
    }

    public void handleGetCurrentConfig(String sessionId, String requestId) {
        Map<String, StreamViewConfig> sessionConfigs = activeConfigs.get(sessionId);
        StreamViewConfig config = sessionConfigs != null ? sessionConfigs.get(requestId) : null;

        messagingTemplate.convertAndSendToUser(
            sessionId,
            "/topic/trades",
            Map.of(
                "type", "CurrentConfig",
                "config", config != null ? config : Map.of()
            )
        );
    }

    /**
     * Вызывается периодически планировщиком для стриминга данных
     */
    public void streamUpdates() {
        activeConfigs.forEach((sessionId, configs) -> {
            configs.values().forEach(config -> {
                try {
                    sendData(sessionId, config, "ReceiveData");
                } catch (Exception e) {
                    log.error("Error streaming to session={}, requestId={}",
                        sessionId, config.getRequestId(), e);
                }
            });
        });
    }

    public void removeSession(String sessionId) {
        activeConfigs.remove(sessionId);
    }

    private void sendData(String sessionId, StreamViewConfig config, String eventType) {
        try {
            QueryResult result = queryService.executeQuery(config);

            messagingTemplate.convertAndSendToUser(
                sessionId,
                "/topic/trades",
                Map.of(
                    "type", eventType,
                    "success", true,
                    "rows", result.rows(),
                    "lastRow", result.totalRows(),
                    "requestId", config.getRequestId()
                )
            );
        } catch (Exception e) {
            log.error("Error executing query for session={}", sessionId, e);

            messagingTemplate.convertAndSendToUser(
                sessionId,
                "/topic/trades",
                Map.of(
                    "type", eventType,
                    "success", false,
                    "error", e.getMessage(),
                    "rows", List.of(),
                    "lastRow", 0,
                    "requestId", config.getRequestId()
                )
            );
        }
    }
}
```

## 8. Пример входящего JSON от клиента

```json
{
  "type": "SetViewConfiguration",
  "data": {
    "startRow": 0,
    "endRow": 100,
    "requestId": "req-001",
    "clientId": "client-123",
    "columns": [
      {"id": 1, "fieldKey": "symbol", "name": "Symbol", "dataType": "string"},
      {"id": 2, "fieldKey": "price", "name": "Price", "dataType": "number"},
      {"id": 3, "fieldKey": "volume", "name": "Volume", "dataType": "number"}
    ],
    "rowGroupColumns": [],
    "valueColumns": [],
    "pivotColumns": [],
    "pivotMode": false,
    "filterModel": {
      "price": {
        "filterType": "number",
        "type": "greaterThan",
        "filter": 100
      },
      "symbol": {
        "filterType": "set",
        "values": ["AAPL", "MSFT", "GOOGL"]
      }
    },
    "sortModel": [
      {"colId": "price", "sort": "desc"}
    ],
    "groupKeys": []
  }
}
```

### Сгенерированный SQL:

```sql
SELECT "symbol", "price", "volume"
FROM "trades"
WHERE "price" > ? AND "symbol" IN (?, ?, ?)
ORDER BY "price" DESC
LIMIT ?
OFFSET ?

-- params: [100, "AAPL", "MSFT", "GOOGL", 100, 0]
```

### Пример с группировкой:

```json
{
  "type": "SetViewConfiguration",
  "data": {
    "startRow": 0,
    "endRow": 50,
    "requestId": "req-002",
    "columns": [
      {"id": 1, "fieldKey": "exchange", "name": "Exchange", "dataType": "string"},
      {"id": 2, "fieldKey": "symbol", "name": "Symbol", "dataType": "string"},
      {"id": 3, "fieldKey": "price", "name": "Price", "dataType": "number"}
    ],
    "rowGroupColumns": [
      {"id": 1, "fieldKey": "exchange", "name": "Exchange", "dataType": "string"},
      {"id": 2, "fieldKey": "symbol", "name": "Symbol", "dataType": "string"}
    ],
    "valueColumns": [
      {"id": 3, "fieldKey": "price", "name": "Price", "dataType": "number", "aggFunc": "avg"}
    ],
    "pivotColumns": [],
    "pivotMode": false,
    "filterModel": {},
    "sortModel": [],
    "groupKeys": ["NYSE"]
  }
}
```

### Сгенерированный SQL:

```sql
SELECT "symbol", AVG("price") AS "price", COUNT(*) AS _group_count
FROM "trades"
WHERE "exchange" = ?
GROUP BY "symbol"
LIMIT ?
OFFSET ?

-- params: ["NYSE", 50, 0]
```

Здесь `groupKeys = ["NYSE"]` означает, что пользователь раскрыл группу "NYSE", и теперь видит группировку по следующему уровню — `symbol`.

## Структура пакетов

```
com.trade.ws/
├── controller/
│   └── TradeController.java
├── model/
│   ├── config/
│   │   ├── GridColumn.java
│   │   ├── GridAggColumn.java
│   │   ├── SortModel.java
│   │   └── StreamViewConfig.java
│   └── request/
│       ├── ClientRequest.java
│       ├── SetViewConfigurationRequest.java
│       ├── RequestImmediateDataRequest.java
│       └── GetCurrentConfigRequest.java
├── service/
│   ├── QueryService.java
│   └── TradeStreamService.java
└── sql/
    ├── SqlQueryBuilder.java
    └── SqlQueryResult.java
```
