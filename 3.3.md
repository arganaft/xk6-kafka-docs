

# SQL Query Builder из StreamViewConfig

Вот класс-конвертер, который преобразует `JsonNode` (содержимое `data` из `SetViewConfiguration`) в SQL-запрос:

```java
package com.example.trade.converter;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ArrayNode;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.StringJoiner;

/**
 * Конвертер StreamViewConfig (JsonNode) в SQL-запрос.
 * <p>
 * Поддерживает:
 * - Выбор колонок (columns)
 * - Группировку (rowGroupColumns + groupKeys для иерархии)
 * - Агрегации (valueColumns с aggFunc)
 * - Pivot-режим (pivotColumns + pivotMode)
 * - Фильтрацию (filterModel)
 * - Сортировку (sortModel)
 * - Пагинацию (startRow / endRow)
 */
public class StreamViewConfigToSqlConverter {

    private static final String DEFAULT_TABLE = "trades";

    /**
     * Основной метод конвертации.
     *
     * @param config JsonNode — содержимое поля "data" из SetViewConfiguration
     * @return SQL-запрос в виде строки
     */
    public static String convert(JsonNode config) {
        return convert(config, DEFAULT_TABLE);
    }

    /**
     * Конвертация с указанием имени таблицы.
     *
     * @param config    JsonNode — содержимое поля "data" из SetViewConfiguration
     * @param tableName имя таблицы/представления в БД
     * @return SQL-запрос в виде строки
     */
    public static String convert(JsonNode config, String tableName) {
        if (config == null) {
            throw new IllegalArgumentException("Config cannot be null");
        }

        boolean pivotMode = config.path("pivotMode").asBoolean(false);
        ArrayNode columns = getArrayNode(config, "columns");
        ArrayNode rowGroupColumns = getArrayNode(config, "rowGroupColumns");
        ArrayNode valueColumns = getArrayNode(config, "valueColumns");
        ArrayNode pivotColumns = getArrayNode(config, "pivotColumns");
        ArrayNode sortModel = getArrayNode(config, "sortModel");
        ArrayNode groupKeys = getArrayNode(config, "groupKeys");
        JsonNode filterModel = config.path("filterModel");
        int startRow = config.path("startRow").asInt(0);
        int endRow = config.path("endRow").asInt(100);

        boolean hasGrouping = rowGroupColumns != null && rowGroupColumns.size() > 0;
        boolean hasAggregation = valueColumns != null && valueColumns.size() > 0;
        boolean hasPivot = pivotMode && pivotColumns != null && pivotColumns.size() > 0;

        StringBuilder sql = new StringBuilder();

        // === SELECT ===
        sql.append("SELECT ");
        String selectClause = buildSelectClause(
                columns, rowGroupColumns, valueColumns, pivotColumns,
                groupKeys, hasGrouping, hasAggregation, hasPivot
        );
        sql.append(selectClause);

        // === FROM ===
        sql.append(" FROM ").append(sanitizeIdentifier(tableName));

        // === WHERE ===
        String whereClause = buildWhereClause(filterModel, rowGroupColumns, groupKeys);
        if (!whereClause.isEmpty()) {
            sql.append(" WHERE ").append(whereClause);
        }

        // === GROUP BY ===
        String groupByClause = buildGroupByClause(rowGroupColumns, groupKeys, hasGrouping, hasPivot, pivotColumns);
        if (!groupByClause.isEmpty()) {
            sql.append(" GROUP BY ").append(groupByClause);
        }

        // === ORDER BY ===
        String orderByClause = buildOrderByClause(sortModel);
        if (!orderByClause.isEmpty()) {
            sql.append(" ORDER BY ").append(orderByClause);
        }

        // === LIMIT / OFFSET ===
        int limit = endRow - startRow;
        if (limit > 0) {
            sql.append(" LIMIT ").append(limit);
        }
        if (startRow > 0) {
            sql.append(" OFFSET ").append(startRow);
        }

        return sql.toString();
    }

    // ==================== SELECT ====================

    private static String buildSelectClause(
            ArrayNode columns,
            ArrayNode rowGroupColumns,
            ArrayNode valueColumns,
            ArrayNode pivotColumns,
            ArrayNode groupKeys,
            boolean hasGrouping,
            boolean hasAggregation,
            boolean hasPivot
    ) {
        List<String> selectParts = new ArrayList<>();

        if (hasGrouping) {
            // Определяем текущий уровень группировки
            int currentLevel = (groupKeys != null) ? groupKeys.size() : 0;

            if (currentLevel < rowGroupColumns.size()) {
                // Ещё есть уровни группировки — показываем колонку текущего уровня
                String groupField = getFieldKey(rowGroupColumns.get(currentLevel));
                selectParts.add(sanitizeIdentifier(groupField));

                // Добавляем агрегации
                if (hasAggregation) {
                    addAggregations(selectParts, valueColumns, hasPivot, pivotColumns);
                }
            } else {
                // Все группы раскрыты — показываем детальные данные
                addColumnsToSelect(selectParts, columns);
            }
        } else if (hasAggregation && !hasPivot) {
            // Агрегация без группировки — просто агрегатные функции
            addAggregations(selectParts, valueColumns, false, null);
        } else {
            // Обычный запрос без группировки
            addColumnsToSelect(selectParts, columns);
        }

        if (selectParts.isEmpty()) {
            return "*";
        }

        return String.join(", ", selectParts);
    }

    private static void addColumnsToSelect(List<String> selectParts, ArrayNode columns) {
        if (columns == null || columns.isEmpty()) {
            selectParts.add("*");
            return;
        }
        for (JsonNode col : columns) {
            String fieldKey = getFieldKey(col);
            if (fieldKey != null) {
                selectParts.add(sanitizeIdentifier(fieldKey));
            }
        }
    }

    private static void addAggregations(
            List<String> selectParts,
            ArrayNode valueColumns,
            boolean hasPivot,
            ArrayNode pivotColumns
    ) {
        if (valueColumns == null) return;

        if (hasPivot && pivotColumns != null && pivotColumns.size() > 0) {
            // В pivot-режиме создаём условные агрегации:
            // SUM(CASE WHEN pivot_col = 'value' THEN agg_col END) AS "value_aggFunc_field"
            // Примечание: для полноценного pivot нужно знать уникальные значения pivot-колонки,
            // что требует предварительного запроса. Здесь генерируем базовую структуру.
            for (JsonNode valCol : valueColumns) {
                String aggFunc = getAggFunc(valCol);
                String fieldKey = getFieldKey(valCol);
                if (fieldKey != null && aggFunc != null) {
                    selectParts.add(
                            aggFunc.toUpperCase() + "(" + sanitizeIdentifier(fieldKey) + ")"
                                    + " AS " + sanitizeIdentifier(fieldKey + "_" + aggFunc)
                    );
                }
            }
        } else {
            for (JsonNode valCol : valueColumns) {
                String aggFunc = getAggFunc(valCol);
                String fieldKey = getFieldKey(valCol);
                if (fieldKey != null && aggFunc != null) {
                    selectParts.add(
                            aggFunc.toUpperCase() + "(" + sanitizeIdentifier(fieldKey) + ")"
                                    + " AS " + sanitizeIdentifier(fieldKey + "_" + aggFunc)
                    );
                }
            }
        }
    }

    // ==================== WHERE ====================

    private static String buildWhereClause(JsonNode filterModel, ArrayNode rowGroupColumns, ArrayNode groupKeys) {
        List<String> conditions = new ArrayList<>();

        // 1. Условия из groupKeys — фильтрация по раскрытым группам
        if (groupKeys != null && rowGroupColumns != null) {
            for (int i = 0; i < groupKeys.size() && i < rowGroupColumns.size(); i++) {
                String groupField = getFieldKey(rowGroupColumns.get(i));
                String groupValue = groupKeys.get(i).asText();
                if (groupField != null) {
                    conditions.add(sanitizeIdentifier(groupField) + " = " + escapeValue(groupValue));
                }
            }
        }

        // 2. Условия из filterModel
        if (filterModel != null && !filterModel.isMissingNode() && filterModel.isObject()) {
            Iterator<Map.Entry<String, JsonNode>> fields = filterModel.fields();
            while (fields.hasNext()) {
                Map.Entry<String, JsonNode> entry = fields.next();
                String fieldName = entry.getKey();
                JsonNode filterDef = entry.getValue();
                String filterSql = buildFilterCondition(fieldName, filterDef);
                if (filterSql != null && !filterSql.isEmpty()) {
                    conditions.add(filterSql);
                }
            }
        }

        return String.join(" AND ", conditions);
    }

    /**
     * Построение условия фильтра для одного поля.
     * Поддерживает ag-Grid форматы фильтров:
     * - Простой фильтр: { filterType, type, filter, filterTo, ... }
     * - Комбинированный: { filterType, operator, condition1, condition2 }
     * - Set-фильтр: { filterType: "set", values: [...] }
     */
    private static String buildFilterCondition(String fieldName, JsonNode filterDef) {
        if (filterDef == null || filterDef.isMissingNode()) {
            return null;
        }

        String filterType = filterDef.path("filterType").asText("");
        String sanitizedField = sanitizeIdentifier(fieldName);

        // Комбинированный фильтр (operator + condition1 + condition2)
        if (filterDef.has("operator")) {
            String operator = filterDef.path("operator").asText("AND");
            String cond1 = buildSingleFilterCondition(sanitizedField, filterDef.get("condition1"), filterType);
            String cond2 = buildSingleFilterCondition(sanitizedField, filterDef.get("condition2"), filterType);

            List<String> parts = new ArrayList<>();
            if (cond1 != null) parts.add(cond1);
            if (cond2 != null) parts.add(cond2);

            if (parts.isEmpty()) return null;
            if (parts.size() == 1) return parts.get(0);

            String logicalOp = "OR".equalsIgnoreCase(operator) ? " OR " : " AND ";
            return "(" + String.join(logicalOp, parts) + ")";
        }

        // Set-фильтр
        if ("set".equalsIgnoreCase(filterType)) {
            return buildSetFilter(sanitizedField, filterDef);
        }

        // Простой фильтр
        return buildSingleFilterCondition(sanitizedField, filterDef, filterType);
    }

    private static String buildSingleFilterCondition(String sanitizedField, JsonNode condition, String filterType) {
        if (condition == null || condition.isMissingNode()) {
            return null;
        }

        String type = condition.path("type").asText("");

        switch (type) {
            case "equals":
                return sanitizedField + " = " + extractFilterValue(condition, filterType);
            case "notEqual":
                return sanitizedField + " != " + extractFilterValue(condition, filterType);
            case "contains":
                return sanitizedField + " LIKE " + escapeValue("%" + condition.path("filter").asText() + "%");
            case "notContains":
                return sanitizedField + " NOT LIKE " + escapeValue("%" + condition.path("filter").asText() + "%");
            case "startsWith":
                return sanitizedField + " LIKE " + escapeValue(condition.path("filter").asText() + "%");
            case "endsWith":
                return sanitizedField + " LIKE " + escapeValue("%" + condition.path("filter").asText());
            case "lessThan":
                return sanitizedField + " < " + extractFilterValue(condition, filterType);
            case "lessThanOrEqual":
                return sanitizedField + " <= " + extractFilterValue(condition, filterType);
            case "greaterThan":
                return sanitizedField + " > " + extractFilterValue(condition, filterType);
            case "greaterThanOrEqual":
                return sanitizedField + " >= " + extractFilterValue(condition, filterType);
            case "inRange":
                String from = extractFilterValue(condition, filterType);
                String to = extractFilterToValue(condition, filterType);
                return sanitizedField + " BETWEEN " + from + " AND " + to;
            case "blank":
            case "empty":
                return "(" + sanitizedField + " IS NULL OR " + sanitizedField + " = '')";
            case "notBlank":
            case "notEmpty":
                return "(" + sanitizedField + " IS NOT NULL AND " + sanitizedField + " != '')";
            default:
                // Если тип не распознан, но есть значение filter — делаем equals
                if (condition.has("filter")) {
                    return sanitizedField + " = " + extractFilterValue(condition, filterType);
                }
                return null;
        }
    }

    private static String buildSetFilter(String sanitizedField, JsonNode filterDef) {
        ArrayNode values = getArrayNode(filterDef, "values");
        if (values == null || values.isEmpty()) {
            return sanitizedField + " IN (NULL)"; // пустой set — ничего не выбрано
        }

        StringJoiner joiner = new StringJoiner(", ");
        boolean hasNull = false;
        for (JsonNode val : values) {
            if (val.isNull()) {
                hasNull = true;
            } else {
                joiner.add(escapeValue(val.asText()));
            }
        }

        if (hasNull && joiner.length() > 0) {
            return "(" + sanitizedField + " IN (" + joiner + ") OR " + sanitizedField + " IS NULL)";
        } else if (hasNull) {
            return sanitizedField + " IS NULL";
        } else {
            return sanitizedField + " IN (" + joiner + ")";
        }
    }

    private static String extractFilterValue(JsonNode condition, String filterType) {
        if ("number".equalsIgnoreCase(filterType)) {
            if (condition.path("filter").isNumber()) {
                return String.valueOf(condition.path("filter").numberValue());
            }
            return condition.path("filter").asText("0");
        }
        if ("date".equalsIgnoreCase(filterType)) {
            String dateFrom = condition.path("dateFrom").asText(null);
            if (dateFrom != null) {
                return escapeValue(dateFrom);
            }
        }
        return escapeValue(condition.path("filter").asText(""));
    }

    private static String extractFilterToValue(JsonNode condition, String filterType) {
        if ("number".equalsIgnoreCase(filterType)) {
            if (condition.path("filterTo").isNumber()) {
                return String.valueOf(condition.path("filterTo").numberValue());
            }
            return condition.path("filterTo").asText("0");
        }
        if ("date".equalsIgnoreCase(filterType)) {
            String dateTo = condition.path("dateTo").asText(null);
            if (dateTo != null) {
                return escapeValue(dateTo);
            }
        }
        return escapeValue(condition.path("filterTo").asText(""));
    }

    // ==================== GROUP BY ====================

    private static String buildGroupByClause(
            ArrayNode rowGroupColumns,
            ArrayNode groupKeys,
            boolean hasGrouping,
            boolean hasPivot,
            ArrayNode pivotColumns
    ) {
        if (!hasGrouping) {
            return "";
        }

        int currentLevel = (groupKeys != null) ? groupKeys.size() : 0;

        if (currentLevel >= rowGroupColumns.size()) {
            // Все группы раскрыты — нет GROUP BY
            return "";
        }

        List<String> groupByFields = new ArrayList<>();

        // Текущий уровень группировки
        String groupField = getFieldKey(rowGroupColumns.get(currentLevel));
        if (groupField != null) {
            groupByFields.add(sanitizeIdentifier(groupField));
        }

        return String.join(", ", groupByFields);
    }

    // ==================== ORDER BY ====================

    private static String buildOrderByClause(ArrayNode sortModel) {
        if (sortModel == null || sortModel.isEmpty()) {
            return "";
        }

        List<String> orderParts = new ArrayList<>();
        for (JsonNode sortItem : sortModel) {
            String colId = sortItem.path("colId").asText(null);
            String sort = sortItem.path("sort").asText("asc");

            if (colId != null && !colId.isEmpty()) {
                String direction = "desc".equalsIgnoreCase(sort) ? "DESC" : "ASC";
                orderParts.add(sanitizeIdentifier(colId) + " " + direction);
            }
        }

        return String.join(", ", orderParts);
    }

    // ==================== Утилиты ====================

    /**
     * Санитизация идентификатора (имя колонки, таблицы).
     * Разрешены только буквы, цифры, подчёркивания и точки.
     * Оборачивается в двойные кавычки для безопасности.
     */
    private static String sanitizeIdentifier(String identifier) {
        if (identifier == null || identifier.isEmpty()) {
            throw new IllegalArgumentException("Identifier cannot be null or empty");
        }
        // Удаляем всё кроме допустимых символов
        String sanitized = identifier.replaceAll("[^a-zA-Z0-9_.]", "");
        if (sanitized.isEmpty()) {
            throw new IllegalArgumentException("Invalid identifier after sanitization: " + identifier);
        }
        // Если содержит точку (schema.table), оборачиваем каждую часть
        if (sanitized.contains(".")) {
            String[] parts = sanitized.split("\\.");
            StringJoiner joiner = new StringJoiner(".");
            for (String part : parts) {
                joiner.add("\"" + part + "\"");
            }
            return joiner.toString();
        }
        return "\"" + sanitized + "\"";
    }

    /**
     * Экранирование строкового значения для SQL.
     * Защита от SQL-инъекций через экранирование одинарных кавычек.
     */
    private static String escapeValue(String value) {
        if (value == null) {
            return "NULL";
        }
        // Экранируем одинарные кавычки удвоением
        String escaped = value.replace("'", "''");
        // Удаляем потенциально опасные символы
        escaped = escaped.replace("\\", "\\\\");
        return "'" + escaped + "'";
    }

    private static String getFieldKey(JsonNode column) {
        if (column == null) return null;
        return column.path("fieldKey").asText(null);
    }

    private static String getAggFunc(JsonNode column) {
        if (column == null) return null;
        String aggFunc = column.path("aggFunc").asText(null);
        if (aggFunc == null) return null;

        // Валидация — только разрешённые функции
        return switch (aggFunc.toLowerCase()) {
            case "sum", "avg", "min", "max", "count" -> aggFunc.toLowerCase();
            default -> null;
        };
    }

    private static ArrayNode getArrayNode(JsonNode parent, String fieldName) {
        JsonNode node = parent.path(fieldName);
        if (node.isArray()) {
            return (ArrayNode) node;
        }
        return null;
    }
}
```

## Интеграция в контроллер

```java
@MessageMapping("/config")
public void handleClientRequest(@Payload JsonNode request, SimpMessageHeaderAccessor headerAccessor) {
    String sessionId = headerAccessor.getSessionId();
    String clientId = (String) headerAccessor.getSessionAttributes().get("clientId");
    String type = request.get("type").asText();
    
    if ("SetViewConfiguration".equals(type)) {
        JsonNode data = request.get("data");
        
        // Конвертация конфигурации в SQL
        String sql = StreamViewConfigToSqlConverter.convert(data);
        
        tradeService.addSubscription(sql, sessionId);
    }
    
    responseSender.sendToSession(sessionId, "Config received for sessionId - " + sessionId);
}
```

## Примеры генерируемого SQL

**Простой запрос с колонками и сортировкой:**
```sql
SELECT "symbol", "price", "volume" FROM "trades" ORDER BY "price" DESC LIMIT 100 OFFSET 0
```

**С фильтрацией:**
```sql
SELECT "symbol", "price", "volume" FROM "trades" 
WHERE "price" > 100 AND "symbol" LIKE 'A%' 
ORDER BY "price" DESC LIMIT 100 OFFSET 0
```

**С группировкой (первый уровень, groupKeys пуст):**
```sql
SELECT "sector", SUM("volume") AS "volume_sum", AVG("price") AS "price_avg" 
FROM "trades" 
GROUP BY "sector" 
ORDER BY "price" DESC LIMIT 100
```

**С раскрытой группой (groupKeys = ["Technology"]):**
```sql
SELECT "symbol", SUM("volume") AS "volume_sum", AVG("price") AS "price_avg" 
FROM "trades" 
WHERE "sector" = 'Technology' 
GROUP BY "symbol" 
ORDER BY "price" DESC LIMIT 100
```

**Set-фильтр:**
```sql
SELECT "symbol", "price" FROM "trades" 
WHERE "symbol" IN ('AAPL', 'MSFT', 'GOOGL') 
LIMIT 100
```

## Ключевые особенности

| Аспект | Реализация |
|--------|-----------|
| **SQL-инъекции** | Идентификаторы санитизируются и оборачиваются в `"кавычки"`, значения экранируются через `''` |
| **Группировка** | Иерархическая — `groupKeys` определяет раскрытые уровни, следующий уровень из `rowGroupColumns` становится `GROUP BY` |
| **Агрегации** | Только whitelist-функции: `sum`, `avg`, `min`, `max`, `count` |
| **Фильтры** | Полная поддержка ag-Grid формата: простые, комбинированные (`AND`/`OR`), set-фильтры, `inRange`, `blank`/`notBlank` |
| **Пагинация** | `LIMIT` / `OFFSET` из `startRow` / `endRow` |
