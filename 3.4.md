# Проблема: `TIMESTAMP` — зарезервированное слово в Apache Calcite

Calcite парсит `timestamp` как начало ключевого слова `TIMESTAMP '2024-01-01'` (литерал даты), а не как имя колонки. Поэтому `SELECT ... timestamp FROM` вызывает ошибку парсера.

## Решение: экранировать имена колонок кавычками

В Calcite зарезервированные слова в качестве идентификаторов нужно оборачивать в двойные кавычки:

```sql
-- ❌ Ошибка
SELECT symbol, price, volume, timestamp FROM trades

-- ✅ Работает
SELECT "symbol", "price", "volume", "timestamp" FROM trades
```

## Исправление в SqlQueryBuilder

Проблема в том, что где-то в коде формируется SQL **без кавычек**. Нужно убедиться, что **все** идентификаторы всегда экранируются.

### Метод sanitizeColumnName — уже правильный

```java
private String sanitizeColumnName(String fieldKey) {
    if (fieldKey == null || fieldKey.isBlank()) {
        throw new IllegalArgumentException("Column name cannot be blank");
    }
    if (!fieldKey.matches("^[a-zA-Z_][a-zA-Z0-9_]*$")) {
        throw new IllegalArgumentException("Invalid column name format: " + fieldKey);
    }
    if (!allowedColumns.contains(fieldKey)) {
        throw new IllegalArgumentException("Column not allowed: " + fieldKey);
    }
    // Двойные кавычки — стандарт SQL для экранирования идентификаторов
    return "\"" + fieldKey + "\"";
}
```

### Проверь все места, где формируется SQL

Ошибка в логе показывает SQL **без кавычек**:

```
SELECT symbol, price, volume, timestamp FROM trades
```

Значит этот запрос формируется **не через `SqlQueryBuilder`**, а где-то ещё. Найди это место. Скорее всего это `CalciteJsonEngine`:

```java
// Найди в CalciteJsonEngine что-то вроде:
String sql = "SELECT " + String.join(", ", columnNames) + " FROM " + tableName;

// Замени на:
String sql = "SELECT " + columnNames.stream()
    .map(col -> "\"" + col + "\"")
    .collect(Collectors.joining(", ")) 
    + " FROM \"" + tableName + "\"";
```

## Полный список зарезервированных слов Calcite, которые часто встречаются в торговых данных

```java
/**
 * Слова, которые ОБЯЗАТЕЛЬНО нужно экранировать в Calcite.
 * Полный список: https://calcite.apache.org/docs/reference.html#keywords
 */
private static final Set<String> CALCITE_RESERVED_WORDS = Set.of(
    "timestamp", "time", "date", "datetime",
    "year", "month", "day", "hour", "minute", "second",
    "order", "group", "select", "from", "where",
    "value", "values", "key", "type", "name",
    "position", "exchange", "current", "user",
    "row", "rows", "rank", "count", "sum",
    "min", "max", "avg", "left", "right",
    "match", "next", "new", "some", "any",
    "all", "both", "leading", "trailing",
    "char", "character", "element", "extract",
    "first", "last", "interval", "trim",
    "upper", "lower", "translate", "convert"
);
```

## Утилитный метод для безопасного экранирования

```java
package com.trade.ws.sql;

/**
 * Утилита для экранирования SQL-идентификаторов в Calcite.
 * ВСЕГДА оборачивает в двойные кавычки — это безопасно и для обычных,
 * и для зарезервированных слов.
 */
public final class SqlIdentifiers {

    private SqlIdentifiers() {}

    /**
     * Экранирует имя колонки/таблицы для использования в SQL.
     * 
     * "timestamp" → "\"timestamp\""
     * "symbol"    → "\"symbol\""
     * 
     * Всегда экранируем — это не влияет на производительность,
     * но гарантирует корректность для любых имён.
     */
    public static String quote(String identifier) {
        if (identifier == null || identifier.isBlank()) {
            throw new IllegalArgumentException("Identifier cannot be blank");
        }
        // Защита от SQL injection через имя идентификатора
        if (!identifier.matches("^[a-zA-Z_][a-zA-Z0-9_]*$")) {
            throw new IllegalArgumentException("Invalid identifier: " + identifier);
        }
        // Экранируем двойные кавычки внутри (на случай если кто-то передаст)
        String escaped = identifier.replace("\"", "\"\"");
        return "\"" + escaped + "\"";
    }

    /**
     * Экранирует составной идентификатор (schema.table)
     * "public.trades" → "\"public\".\"trades\""
     */
    public static String quoteFull(String identifier) {
        if (identifier.contains(".")) {
            String[] parts = identifier.split("\\.");
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < parts.length; i++) {
                if (i > 0) sb.append(".");
                sb.append(quote(parts[i]));
            }
            return sb.toString();
        }
        return quote(identifier);
    }
}
```

## Применение в CalciteJsonEngine

Покажи код `CalciteJsonEngine` — скорее всего исправление будет таким:

```java
// Было (без кавычек):
columns.stream()
    .map(GridColumn::getFieldKey)
    .collect(Collectors.joining(", "))

// Стало (с кавычками):
columns.stream()
    .map(col -> SqlIdentifiers.quote(col.getFieldKey()))
    .collect(Collectors.joining(", "))
```

**Правило: в Calcite ВСЕГДА оборачивай идентификаторы в двойные кавычки.** Это стандарт SQL и работает для любых имён, включая зарезервированные слова вроде `timestamp`, `order`, `exchange`, `value`.
