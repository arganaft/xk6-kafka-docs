# Проблема с Apache Calcite и двойными кавычками

Проблема в том, что **Apache Calcite по умолчанию не использует двойные кавычки (`"`) для квотирования идентификаторов**. Calcite использует стандартный SQL-парсер, и в зависимости от настроенного `Lex` (лексического режима), символ квотирования отличается.

## Корень проблемы

Сгенерированный SQL:
```sql
SELECT "symbol", "price", "volume", "timestamp" FROM "trades" WHERE ...
```

Calcite по умолчанию использует `Lex.ORACLE`, где квотирование идентификаторов — через **обратные кавычки** (`` ` ``) или вообще без кавычек, а `"` интерпретируется как начало строкового литерала.

## Решение

Есть два пути — либо настроить Calcite на поддержку двойных кавычек, либо изменить конвертер. **Лучше сделать оба**.

### 1. Настройка Calcite на `Lex.MYSQL` или `Lex.JAVA`

В месте, где вы создаёте `CalciteConnection` или конфигурируете `FrameworkConfig`:

```java
import org.apache.calcite.config.Lex;
import org.apache.calcite.sql.parser.SqlParser;

SqlParser.Config parserConfig = SqlParser.config()
        .withLex(Lex.MYSQL_ANSI)  // поддерживает двойные кавычки и обратные
        .withCaseSensitive(false);

// Если используете Properties для подключения:
Properties info = new Properties();
info.setProperty("lex", "MYSQL_ANSI");
```

Или если через `model.json` / `CalciteSchema`:

```java
import org.apache.calcite.jdbc.CalciteConnection;

Connection connection = DriverManager.getConnection("jdbc:calcite:", info);
CalciteConnection calciteConnection = connection.unwrap(CalciteConnection.class);
```

### 2. Исправленный конвертер

Главное изменение — **убираем квотирование идентификаторов двойными кавычками** и используем формат, совместимый с Calcite:

```java
package com.example.trade.converter;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ArrayNode;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.StringJoiner;

/**
 * Конвертер StreamViewConfig (JsonNode) в SQL-запрос,
 * совместимый с Apache Calcite.
 *
 * Calcite особенности:
 * - Идентификаторы без кавычек (case-insensitive) или в обратных кавычках
 * - LIMIT/OFFSET не поддерживается напрямую — используем FETCH/OFFSET
 * - Строковые литералы в одинарных кавычках
 */
public class StreamViewConfigToSqlConverter {

    private static final String DEFAULT_TABLE = "trades";

    /**
     * Режим квотирования идентификаторов.
     * Выбирается в зависимости от настройки Lex в Calcite.
     */
    public enum QuotingStyle {
        /** Без кавычек — идентификаторы как есть (case-insensitive в Calcite) */
        NONE,
        /** Двойные кавычки — требует Lex.JAVA или Lex.MYSQL_ANSI */
        DOUBLE_QUOTES,
        /** Обратные кавычки — для Lex.MYSQL */
        BACK_TICKS,
        /** Квадратные скобки — для Lex.SQL_SERVER */
        BRACKETS
    }

    /**
     * Режим пагинации.
     */
    public enum PaginationStyle {
        /** LIMIT x OFFSET y — MySQL, PostgreSQL */
        LIMIT_OFFSET,
        /** OFFSET x ROWS FETCH NEXT y ROWS ONLY — стандартный SQL:2008, Calcite */
        FETCH_OFFSET
    }

    private final QuotingStyle quotingStyle;
    private final PaginationStyle paginationStyle;

    /**
     * Конструктор по умолчанию — без кавычек, FETCH/OFFSET (для Calcite).
     */
    public StreamViewConfigToSqlConverter() {
        this(QuotingStyle.NONE, PaginationStyle.FETCH_OFFSET);
    }

    /**
     * Конструктор с настройками.
     */
    public StreamViewConfigToSqlConverter(QuotingStyle quotingStyle, PaginationStyle paginationStyle) {
        this.quotingStyle = quotingStyle;
        this.paginationStyle = paginationStyle;
    }

    /**
     * Основной метод конвертации.
     *
     * @param config JsonNode — содержимое поля "data" из SetViewConfiguration
     * @return SQL-запрос в виде строки
     */
    public String convert(JsonNode config) {
        return convert(config, DEFAULT_TABLE);
    }

    /**
     * Конвертация с указанием имени таблицы.
     *
     * @param config    JsonNode — содержимое поля "data" из SetViewConfiguration
     * @param tableName имя таблицы/представления в БД
     * @return SQL-запрос в виде строки
     */
    public String convert(JsonNode config, String tableName) {
        if (config == null) {
            throw new IllegalArgumentException("Config cannot be null");
        }

        boolean pivotMode = config.path("pivotMode").asBoolean(false);
        ArrayNode columns = getArrayNode(config, "columns");
        ArrayNode rowGroupColumns = getArrayNode(config, "rowGroupColumns");
        ArrayNode valueColumns = getArrayNode(config, "valueColumns");
        ArrayNode pivotColumns = getArrayNode(config, "pivotColumns");
        ArrayNode sortModel = getArrayNode(config, "sortModel");
        ArrayNode groupKeys = getArrayNode(config, "groupKeys");
        JsonNode filterModel = config.path("filterModel");
        int startRow = config.path("startRow").asInt(0);
        int endRow = config.path("endRow").asInt(100);

        boolean hasGrouping = rowGroupColumns != null && !rowGroupColumns.isEmpty();
        boolean hasAggregation = valueColumns != null && !valueColumns.isEmpty();
        boolean hasPivot = pivotMode && pivotColumns != null && !pivotColumns.isEmpty();

        StringBuilder sql = new StringBuilder();

        // === SELECT ===
        sql.append("SELECT ");
        String selectClause = buildSelectClause(
                columns, rowGroupColumns, valueColumns, pivotColumns,
                groupKeys, hasGrouping, hasAggregation, hasPivot
        );
        sql.append(selectClause);

        // === FROM ===
        sql.append(" FROM ").append(quoteIdentifier(tableName));

        // === WHERE ===
        String whereClause = buildWhereClause(filterModel, rowGroupColumns, groupKeys);
        if (!whereClause.isEmpty()) {
            sql.append(" WHERE ").append(whereClause);
        }

        // === GROUP BY ===
        String groupByClause = buildGroupByClause(rowGroupColumns, groupKeys, hasGrouping);
        if (!groupByClause.isEmpty()) {
            sql.append(" GROUP BY ").append(groupByClause);
        }

        // === ORDER BY ===
        String orderByClause = buildOrderByClause(sortModel);
        if (!orderByClause.isEmpty()) {
            sql.append(" ORDER BY ").append(orderByClause);
        }

        // === PAGINATION ===
        appendPagination(sql, startRow, endRow);

        return sql.toString();
    }

    // ==================== SELECT ====================

    private String buildSelectClause(
            ArrayNode columns,
            ArrayNode rowGroupColumns,
            ArrayNode valueColumns,
            ArrayNode pivotColumns,
            ArrayNode groupKeys,
            boolean hasGrouping,
            boolean hasAggregation,
            boolean hasPivot
    ) {
        List<String> selectParts = new ArrayList<>();

        if (hasGrouping) {
            int currentLevel = (groupKeys != null) ? groupKeys.size() : 0;

            if (currentLevel < rowGroupColumns.size()) {
                String groupField = getFieldKey(rowGroupColumns.get(currentLevel));
                selectParts.add(quoteIdentifier(groupField));

                if (hasAggregation) {
                    addAggregations(selectParts, valueColumns);
                }
            } else {
                addColumnsToSelect(selectParts, columns);
            }
        } else if (hasAggregation) {
            addAggregations(selectParts, valueColumns);
        } else {
            addColumnsToSelect(selectParts, columns);
        }

        if (selectParts.isEmpty()) {
            return "*";
        }

        return String.join(", ", selectParts);
    }

    private void addColumnsToSelect(List<String> selectParts, ArrayNode columns) {
        if (columns == null || columns.isEmpty()) {
            selectParts.add("*");
            return;
        }
        for (JsonNode col : columns) {
            String fieldKey = getFieldKey(col);
            if (fieldKey != null) {
                selectParts.add(quoteIdentifier(fieldKey));
            }
        }
    }

    private void addAggregations(List<String> selectParts, ArrayNode valueColumns) {
        if (valueColumns == null) return;

        for (JsonNode valCol : valueColumns) {
            String aggFunc = getAggFunc(valCol);
            String fieldKey = getFieldKey(valCol);
            if (fieldKey != null && aggFunc != null) {
                selectParts.add(
                        aggFunc.toUpperCase() + "(" + quoteIdentifier(fieldKey) + ")"
                                + " AS " + quoteIdentifier(fieldKey + "_" + aggFunc)
                );
            }
        }
    }

    // ==================== WHERE ====================

    private String buildWhereClause(JsonNode filterModel, ArrayNode rowGroupColumns, ArrayNode groupKeys) {
        List<String> conditions = new ArrayList<>();

        // Условия из groupKeys
        if (groupKeys != null && rowGroupColumns != null) {
            for (int i = 0; i < groupKeys.size() && i < rowGroupColumns.size(); i++) {
                String groupField = getFieldKey(rowGroupColumns.get(i));
                String groupValue = groupKeys.get(i).asText();
                if (groupField != null) {
                    conditions.add(quoteIdentifier(groupField) + " = " + escapeStringValue(groupValue));
                }
            }
        }

        // Условия из filterModel
        if (filterModel != null && !filterModel.isMissingNode() && filterModel.isObject()) {
            Iterator<Map.Entry<String, JsonNode>> fields = filterModel.fields();
            while (fields.hasNext()) {
                Map.Entry<String, JsonNode> entry = fields.next();
                String fieldName = entry.getKey();
                JsonNode filterDef = entry.getValue();
                String filterSql = buildFilterCondition(fieldName, filterDef);
                if (filterSql != null && !filterSql.isEmpty()) {
                    conditions.add(filterSql);
                }
            }
        }

        return String.join(" AND ", conditions);
    }

    private String buildFilterCondition(String fieldName, JsonNode filterDef) {
        if (filterDef == null || filterDef.isMissingNode()) {
            return null;
        }

        String filterType = filterDef.path("filterType").asText("");
        String quotedField = quoteIdentifier(fieldName);

        // Комбинированный фильтр
        if (filterDef.has("operator")) {
            String operator = filterDef.path("operator").asText("AND");
            String cond1 = buildSingleFilterCondition(quotedField, filterDef.get("condition1"), filterType);
            String cond2 = buildSingleFilterCondition(quotedField, filterDef.get("condition2"), filterType);

            List<String> parts = new ArrayList<>();
            if (cond1 != null) parts.add(cond1);
            if (cond2 != null) parts.add(cond2);

            if (parts.isEmpty()) return null;
            if (parts.size() == 1) return parts.getFirst();

            String logicalOp = "OR".equalsIgnoreCase(operator) ? " OR " : " AND ";
            return "(" + String.join(logicalOp, parts) + ")";
        }

        // Set-фильтр
        if ("set".equalsIgnoreCase(filterType)) {
            return buildSetFilter(quotedField, filterDef);
        }

        // Простой фильтр
        return buildSingleFilterCondition(quotedField, filterDef, filterType);
    }

    private String buildSingleFilterCondition(String quotedField, JsonNode condition, String filterType) {
        if (condition == null || condition.isMissingNode()) {
            return null;
        }

        String type = condition.path("type").asText("");

        return switch (type) {
            case "equals" ->
                    quotedField + " = " + extractFilterValue(condition, filterType);
            case "notEqual" ->
                    quotedField + " <> " + extractFilterValue(condition, filterType);
            case "contains" ->
                    quotedField + " LIKE " + escapeStringValue("%" + condition.path("filter").asText() + "%");
            case "notContains" ->
                    quotedField + " NOT LIKE " + escapeStringValue("%" + condition.path("filter").asText() + "%");
            case "startsWith" ->
                    quotedField + " LIKE " + escapeStringValue(condition.path("filter").asText() + "%");
            case "endsWith" ->
                    quotedField + " LIKE " + escapeStringValue("%" + condition.path("filter").asText());
            case "lessThan" ->
                    quotedField + " < " + extractFilterValue(condition, filterType);
            case "lessThanOrEqual" ->
                    quotedField + " <= " + extractFilterValue(condition, filterType);
            case "greaterThan" ->
                    quotedField + " > " + extractFilterValue(condition, filterType);
            case "greaterThanOrEqual" ->
                    quotedField + " >= " + extractFilterValue(condition, filterType);
            case "inRange" -> {
                String from = extractFilterValue(condition, filterType);
                String to = extractFilterToValue(condition, filterType);
                yield quotedField + " BETWEEN " + from + " AND " + to;
            }
            case "blank", "empty" ->
                    "(" + quotedField + " IS NULL OR " + quotedField + " = '')";
            case "notBlank", "notEmpty" ->
                    "(" + quotedField + " IS NOT NULL AND " + quotedField + " <> '')";
            default -> {
                if (condition.has("filter")) {
                    yield quotedField + " = " + extractFilterValue(condition, filterType);
                }
                yield null;
            }
        };
    }

    private String buildSetFilter(String quotedField, JsonNode filterDef) {
        ArrayNode values = getArrayNode(filterDef, "values");
        if (values == null || values.isEmpty()) {
            return quotedField + " IN (NULL)";
        }

        StringJoiner joiner = new StringJoiner(", ");
        boolean hasNull = false;
        for (JsonNode val : values) {
            if (val.isNull()) {
                hasNull = true;
            } else {
                joiner.add(escapeStringValue(val.asText()));
            }
        }

        if (hasNull && joiner.length() > 0) {
            return "(" + quotedField + " IN (" + joiner + ") OR " + quotedField + " IS NULL)";
        } else if (hasNull) {
            return quotedField + " IS NULL";
        } else {
            return quotedField + " IN (" + joiner + ")";
        }
    }

    private String extractFilterValue(JsonNode condition, String filterType) {
        if ("number".equalsIgnoreCase(filterType)) {
            JsonNode filterNode = condition.path("filter");
            if (filterNode.isNumber()) {
                return filterNode.numberValue().toString();
            }
            return filterNode.asText("0");
        }
        if ("date".equalsIgnoreCase(filterType)) {
            String dateFrom = condition.path("dateFrom").asText(null);
            if (dateFrom != null) {
                // Calcite: DATE 'yyyy-MM-dd' или TIMESTAMP 'yyyy-MM-dd HH:mm:ss'
                return formatDateLiteral(dateFrom);
            }
        }
        return escapeStringValue(condition.path("filter").asText(""));
    }

    private String extractFilterToValue(JsonNode condition, String filterType) {
        if ("number".equalsIgnoreCase(filterType)) {
            JsonNode filterToNode = condition.path("filterTo");
            if (filterToNode.isNumber()) {
                return filterToNode.numberValue().toString();
            }
            return filterToNode.asText("0");
        }
        if ("date".equalsIgnoreCase(filterType)) {
            String dateTo = condition.path("dateTo").asText(null);
            if (dateTo != null) {
                return formatDateLiteral(dateTo);
            }
        }
        return escapeStringValue(condition.path("filterTo").asText(""));
    }

    // ==================== GROUP BY ====================

    private String buildGroupByClause(
            ArrayNode rowGroupColumns,
            ArrayNode groupKeys,
            boolean hasGrouping
    ) {
        if (!hasGrouping) {
            return "";
        }

        int currentLevel = (groupKeys != null) ? groupKeys.size() : 0;

        if (currentLevel >= rowGroupColumns.size()) {
            return "";
        }

        String groupField = getFieldKey(rowGroupColumns.get(currentLevel));
        if (groupField != null) {
            return quoteIdentifier(groupField);
        }
        return "";
    }

    // ==================== ORDER BY ====================

    private String buildOrderByClause(ArrayNode sortModel) {
        if (sortModel == null || sortModel.isEmpty()) {
            return "";
        }

        List<String> orderParts = new ArrayList<>();
        for (JsonNode sortItem : sortModel) {
            String colId = sortItem.path("colId").asText(null);
            String sort = sortItem.path("sort").asText("asc");

            if (colId != null && !colId.isEmpty()) {
                String direction = "desc".equalsIgnoreCase(sort) ? "DESC" : "ASC";
                orderParts.add(quoteIdentifier(colId) + " " + direction);
            }
        }

        return String.join(", ", orderParts);
    }

    // ==================== PAGINATION ====================

    private void appendPagination(StringBuilder sql, int startRow, int endRow) {
        int limit = endRow - startRow;

        switch (paginationStyle) {
            case FETCH_OFFSET -> {
                // Стандартный SQL:2008 — поддерживается Calcite
                if (startRow > 0) {
                    sql.append(" OFFSET ").append(startRow).append(" ROWS");
                }
                if (limit > 0) {
                    sql.append(" FETCH NEXT ").append(limit).append(" ROWS ONLY");
                }
            }
            case LIMIT_OFFSET -> {
                // MySQL/PostgreSQL стиль
                if (limit > 0) {
                    sql.append(" LIMIT ").append(limit);
                }
                if (startRow > 0) {
                    sql.append(" OFFSET ").append(startRow);
                }
            }
        }
    }

    // ==================== Утилиты ====================

    /**
     * Квотирование идентификатора в зависимости от выбранного стиля.
     */
    private String quoteIdentifier(String identifier) {
        if (identifier == null || identifier.isEmpty()) {
            throw new IllegalArgumentException("Identifier cannot be null or empty");
        }

        // Санитизация: только буквы, цифры, подчёркивания, точки
        String sanitized = identifier.replaceAll("[^a-zA-Z0-9_.]", "");
        if (sanitized.isEmpty()) {
            throw new IllegalArgumentException("Invalid identifier after sanitization: " + identifier);
        }

        return switch (quotingStyle) {
            case DOUBLE_QUOTES -> {
                if (sanitized.contains(".")) {
                    yield quotePartsWithChar(sanitized, '"');
                }
                yield "\"" + sanitized + "\"";
            }
            case BACK_TICKS -> {
                if (sanitized.contains(".")) {
                    yield quotePartsWithChar(sanitized, '`');
                }
                yield "`" + sanitized + "`";
            }
            case BRACKETS -> {
                if (sanitized.contains(".")) {
                    String[] parts = sanitized.split("\\.");
                    StringJoiner joiner = new StringJoiner(".");
                    for (String part : parts) {
                        joiner.add("[" + part + "]");
                    }
                    yield joiner.toString();
                }
                yield "[" + sanitized + "]";
            }
            case NONE -> {
                // Без кавычек — Calcite обрабатывает как case-insensitive
                yield sanitized;
            }
        };
    }

    private String quotePartsWithChar(String dotSeparated, char quoteChar) {
        String[] parts = dotSeparated.split("\\.");
        StringJoiner joiner = new StringJoiner(".");
        for (String part : parts) {
            joiner.add(String.valueOf(quoteChar) + part + quoteChar);
        }
        return joiner.toString();
    }

    /**
     * Экранирование строкового значения для SQL.
     */
    private static String escapeStringValue(String value) {
        if (value == null) {
            return "NULL";
        }
        String escaped = value.replace("'", "''");
        return "'" + escaped + "'";
    }

    /**
     * Форматирование даты для Calcite.
     * Calcite поддерживает: DATE 'yyyy-MM-dd', TIMESTAMP 'yyyy-MM-dd HH:mm:ss'
     */
    private static String formatDateLiteral(String dateStr) {
        if (dateStr == null) return "NULL";

        // Убираем возможный суффикс 'Z' и миллисекунды для совместимости
        String cleaned = dateStr.replace("T", " ").replace("Z", "");

        // Если содержит время — TIMESTAMP, иначе DATE
        if (cleaned.contains(" ") || cleaned.contains(":")) {
            // Обрезаем до секунд если есть миллисекунды
            if (cleaned.length() > 19) {
                cleaned = cleaned.substring(0, 19);
            }
            return "TIMESTAMP '" + cleaned + "'";
        } else {
            return "DATE '" + cleaned + "'";
        }
    }

    private static String getFieldKey(JsonNode column) {
        if (column == null) return null;
        return column.path("fieldKey").asText(null);
    }

    private static String getAggFunc(JsonNode column) {
        if (column == null) return null;
        String aggFunc = column.path("aggFunc").asText(null);
        if (aggFunc == null) return null;

        return switch (aggFunc.toLowerCase()) {
            case "sum", "avg", "min", "max", "count" -> aggFunc.toLowerCase();
            default -> null;
        };
    }

    private static ArrayNode getArrayNode(JsonNode parent, String fieldName) {
        JsonNode node = parent.path(fieldName);
        if (node.isArray()) {
            return (ArrayNode) node;
        }
        return null;
    }
}
```

## Интеграция в контроллер

```java
// Создаём как бин или поле класса
private final StreamViewConfigToSqlConverter sqlConverter = new StreamViewConfigToSqlConverter();
// По умолчанию: QuotingStyle.NONE + PaginationStyle.FETCH_OFFSET — идеально для Calcite

@MessageMapping("/config")
public void handleClientRequest(@Payload JsonNode request, SimpMessageHeaderAccessor headerAccessor) {
    String sessionId = headerAccessor.getSessionId();
    String clientId = (String) headerAccessor.getSessionAttributes().get("clientId");
    String type = request.get("type").asText();
    
    if ("SetViewConfiguration".equals(type)) {
        JsonNode data = request.get("data");
        String sql = sqlConverter.convert(data);
        // sql теперь совместим с Calcite
        tradeService.addSubscription(sql, sessionId);
    }
    
    responseSender.sendToSession(sessionId, "Config received for sessionId - " + sessionId);
}
```

## Результат для вашего примера

**Было (ошибка):**
```sql
SELECT "symbol", "price", "volume", "timestamp" 
FROM "trades" 
WHERE "symbol" = 'AAPL' AND "price" > 150 AND "volume" BETWEEN 10000 AND 50000 
ORDER BY "timestamp" DESC 
LIMIT 100
```

**Стало (работает с Calcite):**
```sql
SELECT symbol, price, volume, timestamp 
FROM trades 
WHERE symbol = 'AAPL' AND price > 150 AND volume BETWEEN 10000 AND 50000 
ORDER BY timestamp DESC 
FETCH NEXT 100 ROWS ONLY
```

## Сводка изменений

| Проблема | Было | Стало |
|----------|------|-------|
| Квотирование идентификаторов | `"symbol"` (двойные кавычки) | `symbol` (без кавычек) |
| Пагинация | `LIMIT 100` | `FETCH NEXT 100 ROWS ONLY` |
| Оператор неравенства | `!=` | `<>` (стандартный SQL) |
| Даты | `'2026-02-13'` | `DATE '2026-02-13'` / `TIMESTAMP '...'` |
| Гибкость | Статические методы | Настраиваемый через `QuotingStyle` + `PaginationStyle` |

Если в будущем потребуется переключиться на другую БД:

```java
// Для PostgreSQL
new StreamViewConfigToSqlConverter(QuotingStyle.DOUBLE_QUOTES, PaginationStyle.LIMIT_OFFSET);

// Для MySQL
new StreamViewConfigToSqlConverter(QuotingStyle.BACK_TICKS, PaginationStyle.LIMIT_OFFSET);

// Для SQL Server
new StreamViewConfigToSqlConverter(QuotingStyle.BRACKETS, PaginationStyle.FETCH_OFFSET);
```
