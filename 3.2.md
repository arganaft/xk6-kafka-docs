Конечно. Для того чтобы отладить WebSocket, нам понадобится простая HTML-страница, которая использует библиотеки **SockJS** и **Stomp.js**.

Вот пошаговая инструкция, как добавить простой Front-end в твой Spring Boot проект.

### Шаг 1. Проверь зависимости (pom.xml)

Чтобы Spring Boot мог отдавать HTML-страницы (шаблоны), нам понадобится **Thymeleaf**. Убедись, что в `pom.xml` есть эта зависимость. Если нет — добавь её:

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

### Шаг 2. Создай контроллер для страницы

Создай новый класс, например `PageController`, чтобы по запросу `/websocket/trades` отдавать нашу страницу.

```java
package com.websocket.trade.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class PageController {

    @GetMapping("/websocket/trades")
    public String getTradesPage() {
        // Spring будет искать файл index.html в папке resources/templates
        return "index";
    }
}
```

### Шаг 3. Создай HTML-страницу

Создай файл `index.html` по пути: `src/main/resources/templates/index.html`.

Этот код содержит минимальный UI: кнопки подключения, поле для отправки конфига (фильтра) и лог сообщений.

```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>WebSocket Trade Debugger</title>
    <!-- Подключаем Bootstrap для красоты -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Библиотеки для WebSocket -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.6.1/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
    
    <style>
        #conversation { display: none; }
        #messages { height: 300px; overflow-y: scroll; background: #f8f9fa; border: 1px solid #ddd; padding: 10px; }
    </style>
</head>
<body class="container mt-4">

<h2>WebSocket Trade Debugger</h2>

<div class="row mb-3">
    <div class="col-md-6">
        <div class="card">
            <div class="card-body">
                <h5 class="card-title">1. Соединение</h5>
                <div class="mb-3">
                    <label for="wsEndpoint" class="form-label">Endpoint</label>
                    <input type="text" class="form-control" id="wsEndpoint" value="/ws">
                </div>
                <button id="connect" class="btn btn-primary" onclick="connect()">Connect</button>
                <button id="disconnect" class="btn btn-danger" onclick="disconnect()" disabled>Disconnect</button>
                <span id="status" class="badge bg-secondary ms-2">Disconnected</span>
            </div>
        </div>
    </div>
    
    <div class="col-md-6">
        <div class="card">
            <div class="card-body">
                <h5 class="card-title">2. Отправка конфига (Подписка)</h5>
                <p class="text-muted small">Чтобы получать данные, нужно отправить конфиг на сервер.</p>
                <div class="mb-3">
                    <label for="destination" class="form-label">Destination (Куда слать)</label>
                    <!-- Обычно это что-то вроде /app/config или /app/subscribe -->
                    <input type="text" class="form-control" id="destination" value="/app/config"> 
                </div>
                <div class="mb-3">
                    <label for="jsonConfig" class="form-label">JSON Config</label>
                    <textarea class="form-control" id="jsonConfig" rows="3">
{
  "requestId": "req-1",
  "filters": []
}
                    </textarea>
                </div>
                <button id="send" class="btn btn-success" onclick="sendConfig()" disabled>Send Config</button>
            </div>
        </div>
    </div>
</div>

<div class="row">
    <div class="col-12">
        <h4>Лог сообщений (Topic: /user/topic/trades)</h4>
        <div id="messages"></div>
        <button class="btn btn-secondary btn-sm mt-2" onclick="clearLog()">Очистить лог</button>
    </div>
</div>

<script>
    var stompClient = null;

    function setConnected(connected) {
        document.getElementById('connect').disabled = connected;
        document.getElementById('disconnect').disabled = !connected;
        document.getElementById('send').disabled = !connected;
        document.getElementById('status').className = connected ? 'badge bg-success ms-2' : 'badge bg-secondary ms-2';
        document.getElementById('status').innerText = connected ? 'Connected' : 'Disconnected';
    }

    function connect() {
        var endpoint = document.getElementById('wsEndpoint').value;
        var socket = new SockJS(endpoint);
        stompClient = Stomp.over(socket);
        
        stompClient.connect({}, function (frame) {
            setConnected(true);
            console.log('Connected: ' + frame);
            log("--- Соединение установлено ---");

            // ПОДПИСКА НА ЛИЧНЫЙ КАНАЛ ПОЛЬЗОВАТЕЛЯ
            // Spring автоматически преобразует /user/topic/trades в уникальную очередь для сессии
            stompClient.subscribe('/user/topic/trades', function (message) {
                log("RECEIVED: " + message.body);
            });

        }, function (error) {
            console.log(error);
            log("ERROR: " + error);
            setConnected(false);
        });
    }

    function disconnect() {
        if (stompClient !== null) {
            stompClient.disconnect();
        }
        setConnected(false);
        log("--- Соединение закрыто ---");
    }

    function sendConfig() {
        var destination = document.getElementById('destination').value;
        var jsonConfig = document.getElementById('jsonConfig').value;
        
        try {
            // Проверяем валидность JSON
            JSON.parse(jsonConfig); 
            stompClient.send(destination, {}, jsonConfig);
            log("SENT to " + destination + ": " + jsonConfig);
        } catch (e) {
            alert("Ошибка в JSON! Проверьте синтаксис.");
        }
    }

    function log(message) {
        var messagesDiv = document.getElementById('messages');
        var p = document.createElement('p');
        p.style.wordWrap = 'break-word';
        p.style.borderBottom = '1px solid #eee';
        p.style.margin = '0';
        p.style.padding = '5px';
        
        // Добавляем время
        var time = new Date().toLocaleTimeString();
        p.innerText = `[${time}] ${message}`;
        
        messagesDiv.prepend(p);
    }
    
    function clearLog() {
        document.getElementById('messages').innerHTML = '';
    }
</script>

</body>
</html>
```

### Как тестировать

1.  Запусти приложение.
2.  Открой в браузере: `http://localhost:8080/websocket/trades`.
3.  Нажми кнопку **Connect**.
    *   Должен загореться зеленый статус "Connected".
    *   В логе появится сообщение о подписке на `/user/topic/trades`.
4.  **Важный момент:** Чтобы `TradeService` начал слать данные, он должен знать о твоей сессии. Обычно для этого нужно отправить сообщение с конфигурацией.
    *   В поле "Destination" укажи эндпоинт, который слушает твой контроллер (например, `@MessageMapping("/config")` -> `/app/config`).
    *   В поле JSON вставь нужный конфиг.
    *   Нажми **Send Config**.
5.  **Симуляция данных:**
    *   Так как у тебя есть `DataIngestHandler`, скорее всего, данные приходят извне (через REST).
    *   Открой Postman или консоль и отправь POST запрос с данными сделок на твой REST-контроллер (например, `http://localhost:8080/api/ingest`).
    *   Если всё настроено верно, `TradeService` отфильтрует эти данные и отправит их в WebSocket, и ты увидишь их в браузере в блоке "Лог сообщений".
